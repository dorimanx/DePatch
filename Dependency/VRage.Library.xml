<?xml version="1.0"?>
<doc>
    <assembly>
        <name>VRage.Library</name>
    </assembly>
    <members>
        <member name="M:VRage.Algorithms.IMyPathEdge`1.GetOtherVertex(`0)">
            <summary>
            Returns the other vertex on this edge.
            Can return null, if the edge is a loop or if the edge is not traversable
            </summary>
        </member>
        <member name="M:VRage.Algorithms.IMyPathVertex`1.EstimateDistanceTo(VRage.Algorithms.IMyPathVertex{`0})">
            <summary>
            Heuristic on the shortest path to another vertex. Used for finding the shortest path.
            </summary>
        </member>
        <member name="M:VRage.Algorithms.IMyPathVertex`1.GetNeighborCount">
            <summary>
            Returns the number of neighbouring vertices.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:VRage.Algorithms.IMyPathVertex`1.GetNeighbor(System.Int32)" -->
        <member name="M:VRage.Algorithms.IMyPathVertex`1.GetEdge(System.Int32)">
            <summary>
            Gets N-th edge of this vertex.
            Must be consistent with the GetNeighbor() function.
            </summary>
        </member>
        <member name="M:VRage.Algorithms.MyPathFindingSystem`1.PrepareTraversal(`0,System.Predicate{`0},System.Predicate{`0},System.Predicate{VRage.Algorithms.IMyPathEdge{`0}})">
            <summary>
            Has to be called before any traversal of the pathfinding system using enumerators.
            
            Several predicates can be supplied to the system that change the behavior of the traversal.
            </summary>
            <param name="startingVertex">The vertex from which the traversal starts</param>
            <param name="vertexFilter">If set, this predicate is applied to the output vertices so that we only get those that we are interested in.</param>
            <param name="vertexTraversable">
                This predicate allows to make vertices of the graph untraversable, blocking the paths through them.
                It is guaranteed to be called only once on every vertex when enumerating the graph or finding reachable vertices, but
                for pathfinding functions, this guarantee is no longer valid.
            </param>
            <param name="edgeTraversable">This predicate allows to make edges untraversable, blocking the paths through them.</param>
        </member>
        <member name="T:VRage.Algorithms.MyUnionFind">
            <summary>
             Fast representation for disjoint sets.
            
            This data structure guarantees virtually constant time operations
            for union and finding the representative element of disjoint sets.
            </summary>
            
            Still wondering weather the iterator makes sence
        </member>
        <member name="T:VRage.Library.Algorithms.SequenceIdGenerator">
            <summary>
            Generates IDs sequentially and reuses old IDs which are returned to pool by calling Return method.
            Protection count and time can be set to protect returned IDs. 
            Protection is useful especially in multiplayer where clients can still have objects with those IDs.
            </summary>
        </member>
        <member name="F:VRage.Library.Algorithms.SequenceIdGenerator.m_maxId">
            <summary>
            Max used id, zero is reserved and never used.
            </summary>
        </member>
        <member name="F:VRage.Library.Algorithms.SequenceIdGenerator.m_protecionCount">
            <summary>
            Minimal number of items in reuse queue until first item can be taken.
            </summary>
        </member>
        <member name="F:VRage.Library.Algorithms.SequenceIdGenerator.m_reuseProtectionTime">
            <summary>
            Minimal time if item spent in reuse queue until it can be returned.
            Units are arbitrary
            </summary>
        </member>
        <member name="F:VRage.Library.Algorithms.SequenceIdGenerator.m_timeFunc">
            <summary>
            Function which returns current time, units are arbitrary and same as reuse protection time.
            </summary>
        </member>
        <member name="P:VRage.Library.Algorithms.SequenceIdGenerator.ReservedCount">
            <summary>
            Number of reserved ids, zero is also reserved, but not counted.
            </summary>
        </member>
        <member name="M:VRage.Library.Algorithms.SequenceIdGenerator.CreateWithStopwatch(System.TimeSpan,System.Int32)">
            <summary>
            Creates new sequence id generator with stopwatch to measure protection time.
            </summary>
            <param name="reuseProtectionTime">Time to protect returned IDs.</param>
            <param name="reuseProtectionCount">Minimum number of IDs in protection queue, before first ID will be reused.</param>
        </member>
        <member name="M:VRage.Library.Algorithms.SequenceIdGenerator.Reserve(System.UInt32)">
            <summary>
            Reserves first several IDs, so it's never returned by generator.
            Zero is never returned, when reservedIdCount is 2, IDs 1 and 2 won't be ever returned.
            </summary>
            <param name="reservedIdCount">Number of reserved IDs which will be never returned by generator.</param>
        </member>
        <member name="T:VRage.Library.Collections.BitReader">
            <summary>
            Lightweight bit reader which works on native pointer.
            Stores bit length and current position.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitReaderWriter.ReadData(VRage.Library.Collections.IBitSerializable,System.Boolean,System.Boolean)">
            <summary>
            Returns false when validation was required and failed, otherwise true.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.BitStream">
            <summary>
            Stream which writes data based on bits.
            When writing, buffer must be reset to zero to write values correctly, this is done by ResetWrite() methods or SetPositionAndClearForward()
            </summary>
        </member>
        <member name="F:VRage.Library.Collections.BitStream.MaxSize">
            <summary>
            Maximum number of bits the bit stream can hold.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.BitStream.BitPosition">
            <summary>
            Read/write bit position in stream.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.BitStream.BitLength">
            <summary>
            Length of valid data (when reading) or buffer (when writing) in bits.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.BitStream.BytePosition">
            <summary>
            Position in stream round up to whole bytes.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.BitStream.ByteLength">
            <summary>
            Length of valid data (when reading) or buffer (when writing) round up to whole bytes
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.BitStream.OwnsBuffer">
            <summary>
            Returns true when owns buffers, always true when writing.
            May or may not own buffer when reading.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.BitStream.Writing">
            <summary>
            True when stream is for writing.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.ResetRead">
            <summary>
            Resets stream for reading (reads what was written so far).
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.ResetRead(System.Byte[],System.Int32,System.Int64,System.Boolean)">
            <summary>
            Resets stream for reading and copies data.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.ResetRead(System.IntPtr,System.Int64,System.Boolean)">
            <summary>
            Resets stream for reading.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.ResetWrite">
            <summary>
            Resets stream for writing.
            Uses internal buffer for writing, it's available as DataPointer.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SerializeVariant(System.Int32@)">
            <summary>
            Efficiently serializes small integers. Closer to zero, less bytes.
            From -64 to 63 (inclusive), 8 bits.
            From -8 192 to 8 191 (inclusive), 16 bits.
            From -1 048 576 to 1 048 575, 24 bits.
            From -134 217 728 to 134 217 727, 32 bits.
            Otherwise 40 bits.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SerializeVariant(System.Int64@)">
            <summary>
            Efficiently serializes small integers. Closer to zero, less bytes.
            From -64 to 63 (inclusive), 8 bits.
            From -8192 to 8191 (inclusive), 16 bits.
            From -1048576 to 1048575, 24 bits.
            From -134217728 to 134217727, 32 bits.
            Etc...
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SerializeVariant(System.UInt32@)">
            <summary>
            Efficiently serializes small integers. Closer to zero, less bytes.
            0 - 127, 8 bits.
            128 - 16383, 16 bits.
            16384 - 2097151, 24 bits.
            2097152 - 268435455, 32 bits.
            Otherwise 40 bits.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SerializeVariant(System.UInt64@)">
            <summary>
            Efficiently serializes small integers. Closer to zero, less bytes.
            0 - 127, 8 bits.
            128 - 16383, 16 bits.
            16384 - 2097151, 24 bits.
            2097152 - 268435455, 32 bits.
            Etc...
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.Serialize(System.Char@)">
            <summary>
            Writes char as UTF16, 2-byte value.
            For ASCII or different encoding, use SerializeByte() or SerializeBytes().
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SerializeMemory(System.IntPtr,System.Int64)">
            <summary>
            Serializes fixed size memory region.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SerializeMemory(System.Void*,System.Int64)">
            <summary>
            Serializes fixed size memory region.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SerializePrefixString(System.String@,System.Text.Encoding)">
            <summary>
            Serializes string length (as UInt32 variant) and string itself in defined encoding.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SerializePrefixStringAscii(System.String@)">
            <summary>
            Serializes string length (as UInt32 variant) and string itself encoded with ASCII encoding.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SerializePrefixStringUtf8(System.String@)">
            <summary>
            Serializes string length (as UInt32 variant) and string itself encoded with UTF8 encoding.
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SerializePrefixBytes(System.Byte[]@)">
            <summary>
            Serializes byte array length (as UInt32 variant) and bytes.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SerializeBytes(System.Byte[]@,System.Int32,System.Int32)">
            <summary>
            Serializes fixed-size byte array or it's part (length is NOT serialized).
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.ReadNormalizedSignedFloat(System.Int32)">
            <summary>
            Reads uniform-spaced float within -1,1 range with specified number of bits.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.ReadPrefixLengthString(System.Char[]@,System.Text.Encoding)">
            <summary>
            Reads prefixed length string, returns nubmer of characters read.
            Passed array is automatically resized when needed.
            </summary>
            <returns>Nubmer of characters read.</returns>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.SetBitPositionWrite(System.Int64)">
            <summary>
            Use when you need to overwrite part of the data.
            Sets new bit position and clears everything from min(old position, new position) to end of stream.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.WriteNormalizedSignedFloat(System.Single,System.Int32)">
            <summary>
            Writes uniform-spaced float within -1,1 range with specified number of bits.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.WriteVariantSigned(System.Int32)">
            <summary>
            Efficiently writes small integers. Closer to zero, less bytes.
            From -64 to 63 (inclusive), 8 bits.
            From -8 192 to 8 191 (inclusive), 16 bits.
            From -1 048 576 to 1 048 575, 24 bits.
            From -134 217 728 to 134 217 727, 32 bits.
            Otherwise 40 bits.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.WriteVariantSigned(System.Int64)">
            <summary>
            Efficiently writes small integers. Closer to zero, less bytes.
            From -64 to 63 (inclusive), 8 bits.
            From -8192 to 8191 (inclusive), 16 bits.
            From -1048576 to 1048575, 24 bits.
            From -134217728 to 134217727, 32 bits.
            Etc...
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.WriteVariant(System.UInt32)">
            <summary>
            Efficiently writes small integers. Closer to zero, less bytes.
            0 - 127, 8 bits.
            128 - 16383, 16 bits.
            16384 - 2097151, 24 bits.
            2097152 - 268435455, 32 bits.
            Otherwise 40 bits.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.BitStream.WriteVariant(System.UInt64)">
            <summary>
            Efficiently writes small integers. Closer to zero, less bytes.
            0 - 127, 8 bits.
            128 - 16383, 16 bits.
            16384 - 2097151, 24 bits.
            2097152 - 268435455, 32 bits.
            Etc...
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.DynamicSerializerDelegate">
            <summary>
            Dynamic object serializer, when writing, serializes object type.
            When reading deserializes object type and creates new instance.
            </summary>
            <param name="stream">Stream to read from or write to.</param>
            <param name="baseType">Hierarchy base type of dynamically serialized object, can be used to select serialization method (e.g. object builders have something special).</param>
            <param name="obj">Object whose type to write or read and instantiate.</param>
        </member>
        <member name="M:VRage.Library.Collections.IBitSerializable.Serialize(VRage.Library.Collections.BitStream,System.Boolean,System.Boolean)">
            <summary>
            When reading, returns false when validation was required and failed, otherwise true.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.LRUCache`2.TryPeek(`0,`1@)">
            <summary>
            Read an entry from the cache without modifying the cache order.
            </summary>
            <param name="key">The entry key.</param>
            <param name="value">The entry if found.</param>
            <returns>Whether the entry was found.</returns>
        </member>
        <member name="M:VRage.Library.Collections.LRUCache`2.Write(`0,`1)">
             <summary>
             Write an entry into the cache.
            
             If the cache is full the oldest record is evicted in order to make room for the new one.
             </summary>
             <param name="key"></param>
             <param name="value"></param>
        </member>
        <member name="M:VRage.Library.Collections.LRUCache`2.Remove(`0)">
            <summary>
            Try to remove an entry from the cache.
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:VRage.Library.Collections.LRUCache`2.RemoveWhere(System.Func{`0,`1,System.Boolean})">
            <summary>
            Remove every entry in the cache that matches the predicate.
            </summary>
            <param name="entryAction"></param>
            <returns>The number of entries removed.</returns>
        </member>
        <member name="M:VRage.Library.Collections.LRUCache`2.AssertConsistent">
            <summary>
            Verifies that all assumptions are met (linked list is connected and all lookups are correct).
            FULLDEBUG is only here to disable this. Enable by changing to DEBUG if you suspect problems.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MyCollectionDictionary`3">
            <summary>
            Base class for dictionaries that store multiple elements under a key using some collection.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.MyCollectionDictionary`3.TryGet(`0,`1@)">
            <summary>
            Try get a collection for the provided key.
            </summary>
            <param name="key"></param>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="P:VRage.Library.Collections.MyFreeList`1.UsedLength">
            <summary>
            Length of the internal buffer occupied by a mix of free and empty nodes, data past this length is all free.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.MyFreeList`1.Count">
            <summary>
            Total number of allocated positions.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MyHashSetDictionary`2">
            <summary>
            Collection which stores multiple elements under same key by using list.
            Collection does not allow removing single value, only all items with same key.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MyIndexArray`1">
            <summary>
            Automatically resizing array when accessing index.
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.MyIndexArray`1.TrimExcess(System.Single,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Trims end of array which contains default elements.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.__helper_namespace.ITypeList">
            <summary>
            Interface describing a generic type list.
            
            We use these as indices for the type dictionary.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.__helper_namespace.TypeList">
            <summary>
            Basic type list implementation.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.__helper_namespace.TypeListWith">
            <summary>
            Type list with a single element added.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.__helper_namespace.TypeListWithout">
            <summary>
            Type list with a single element added.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MyComponentContainerTemplate`1">
            <summary>
            Template for an indexed component container.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:VRage.Library.Collections.ComponentIndex">
            <summary>
            Index for a component container.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.IndexHost">
            <summary>
            Host of static references to indexers.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MyIndexedComponentContainer`1">
            <summary>
            Component container that stores the components in a list and uses a shared index for quick access.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:VRage.Library.Collections.MyIndexedComponentContainer`1.#ctor(VRage.Library.Collections.MyComponentContainerTemplate{`0})">
            <summary>
            Create a component from a template.
            </summary>
            <param name="template">template</param>
        </member>
        <member name="T:VRage.Library.Collections.MyIndexList`1">
            <summary>
            Stores items in list with fixed index (no reordering).
            Null is used as special value and cannot be added into list.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.MyIndexList`1.NextIndex">
            <summary>
            Returns what will be next index returned by Add operation.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MyList`1">
            <summary>
            Implementation of a list with additional utility methods and access to the internal array.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:VRage.Library.Collections.MyList`1.InsertFrom(System.Collections.Generic.IList{`0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Add the specified range of items from <paramref name="list"/> into this collection at the specified position.
            </summary>
            <param name="list">The list to copy the elements from.</param>
            <param name="sourceIndex">The source </param>
            <param name="count">The number of elements to take from the list.</param>
        </member>
        <member name="M:VRage.Library.Collections.MyList`1.RemoveAllFast(System.Predicate{`0})">
            <summary>Quickly removes all the elements that match the conditions defined by the specified predicate.</summary>
            <remarks>This version of the method does not preserve the order of the list, but is faster to execute.</remarks>
            <param name="match">The <see cref="T:System.Predicate`1"></see> delegate that defines the conditions of the elements to remove.</param>
            <returns>The number of elements removed from the <see cref="T:System.Collections.Generic.List`1"></see> .</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="match">match</paramref> is null.</exception>
        </member>
        <member name="M:VRage.Library.Collections.MyList`1.ClearFast">
            <summary>
            Quickly clear this list.
            </summary>
            <remarks>This method will only reset the internal size counter, individual items will not be modified and as a result object references may be kep for longer than expected.</remarks>
        </member>
        <member name="M:VRage.Library.Collections.MyList`1.ClearForced">
            <summary>
            Clear the entire allocated length of the internal array.
            </summary>
            <remarks><para>This method can be used after <see cref="M:VRage.Library.Collections.MyList`1.ClearFast"/> to ensure no object references are kept by free slots in the internal array.</para>
            <para>It is important to realize that calling both <see cref="M:VRage.Library.Collections.MyList`1.ClearFast"/> and <see cref="M:VRage.Library.Collections.MyList`1.ClearForced"/> is sequence is potentially slower than regular <see cref="M:VRage.Library.Collections.MyList`1.ClearFast"/>.
            This method is instead intended to be used only occasionally or at the end of the life cycle of lists that act like buffers and are fast-cleared frequently.</para></remarks>
        </member>
        <member name="M:VRage.Library.Collections.MyList`1.Touch">
            <summary>
            This method should be called after modifying the internal array of this list.
            </summary>
            <remarks>Some methods such as <see cref="M:VRage.Library.Collections.MyList`1.SetSize(System.Int32)"/> can be called instead to achieve the same result.</remarks>
            <seealso cref="M:VRage.Library.Collections.MyList`1.GetInternalArray"/>
        </member>
        <member name="M:VRage.Library.Collections.MyList`1.SetSize(System.Int32)">
            <summary>
            Modify the internal size of the list.
            </summary>
            <remarks>This method can be used for fast truncation or after the list contents are filled in directly.</remarks>
            <param name="size"></param>
            <seealso cref="M:VRage.Library.Collections.MyList`1.GetInternalArray"/>
        </member>
        <member name="M:VRage.Library.Collections.MyList`1.MoveForward(System.Int32,System.Int32)">
            <summary>
            Move array elements forward.
            </summary>
            <param name="index"></param>
            <param name="count"></param>
        </member>
        <member name="M:VRage.Library.Collections.MyList`1.MoveBackward(System.Int32,System.Int32)">
            <summary>
            Move array elements backward.
            </summary>
            <param name="index"></param>
            <param name="count"></param>
        </member>
        <member name="M:VRage.Library.Collections.MyList`1.GetInternalArray">
            <summary>
            Provide access to the array used internally to store the list items.
            </summary>
            <remarks>
            <para>If elements of the array are modified the user should call <see cref="M:VRage.Library.Collections.MyList`1.Touch"/> to inform of that change.</para>
            <para>Any addition/insertion to the list may re-allocate the internal array, thus invalidating the instance returned by this method.</para>
            </remarks>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Collections.MyList`1.AsSpan">
            <summary>
            Provide access to the array used internally to store the list items.
            </summary>
            <remarks>
            <para>If elements of the array are modified the user should call <see cref="M:VRage.Library.Collections.MyList`1.Touch"/> to inform of that change.</para>
            <para>Any addition/insertion to the list may re-allocate the internal array, thus invalidating the instance returned by this method.</para>
            </remarks>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Collections.MyList`1.Slice(System.Int32,System.Int32)">
            <summary>
            Provide access to a slice of the array used internally to store the list items.
            </summary>
            <remarks>
            <para>If elements of the array are modified the user should call <see cref="M:VRage.Library.Collections.MyList`1.Touch"/> to inform of that change.</para>
            <para>Any addition/insertion to the list may re-allocate the internal array, thus invalidating the instance returned by this method.</para>
            </remarks>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Collections.MyList`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <internalonly/>
        </member>
        <member name="T:VRage.Library.Collections.MyListDictionary`2">
            <summary>
            Collection which stores multiple elements under same key by using list.
            Collection does not allow removing single value, only all items with same key.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MyMultiKeyDictionary`3">
            <summary>
            MyMultiKeyDictionary supports value lookups using multiple different keys.
            When keys can be derived from value, use MultiKeyIndex.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MyMultiKeyDictionary`4">
            <summary>
            MyMultiKeyDictionary supports value lookups using multiple different keys.
            When keys can be derived from value, use MultiKeyIndex.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MyMultiKeyIndex`3">
            <summary>
            MultiKeyIndex supports value lookups using multiple different keys.
            The keys must derivable from value, if it's not the case use MultiKeyDictionary.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.MyMultiKeyIndex`4">
            <summary>
            MultiKeyIndex supports value lookups using multiple different keys.
            The keys must derivable from value, if it's not the case use MultiKeyDictionary.
            </summary>
        </member>
        <member name="T:VRage.Library.Collections.PooledMemory`1">
            <summary>
            Represents a type-safe segment of memory that is borrowed from a pool.
            </summary>
            <seealso cref="T:VRage.Library.Collections.PoolManager"/>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:VRage.Library.Collections.PooledMemory`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:VRage.Library.Collections.PoolManager">
            <summary>
            A simple thread safe manager for all sorts of pooled objects.
            
            This 
            </summary>
        </member>
        <member name="M:VRage.Library.Collections.PoolManager.Preallocate``1(System.Int32)">
            <summary>
            Preallocate a number of elements for a given object pool.
            
            This call only produces an effect if the pool has not yet been initialized.
            </summary>
            <typeparam name="TPooled">The type of the pooled object.</typeparam>
            <param name="size">The number of elements to preallocate, this can be zero.</param>
        </member>
        <member name="M:VRage.Library.Collections.PoolManager.Get``1">
            <summary>
            Get an instance from a pool.
            
            Pooled resources represent data structures that are cached to prevent unnecessary memory allocations in time critical moments.
            
            Pooled resources must always be return to the pool when no longer necessary.
            </summary>
            <typeparam name="TPooled">The type of the object to retrieve.</typeparam>
            <returns>Retrieve an instance of an object from the appropriate pool, if no pool exists one is created for the type.</returns>
        </member>
        <member name="M:VRage.Library.Collections.PoolManager.Get``1(``0@)">
            <summary>
            Get an instance from a pool.
            
            Pooled resources represent data structures that are cached to prevent unnecessary memory allocations in time critical moments.
            
            Pooled resources must always be return to the pool when no longer necessary.
            </summary>
            <typeparam name="TPooled">The type of the object to retrieve.</typeparam>
            <returns>Retrieve an instance of an object from the appropriate pool, if no pool exists one is created for the type.</returns>
        </member>
        <member name="M:VRage.Library.Collections.PoolManager.Return``1(``0@)">
            <summary>
            Return an object to it's pool.
            
            Note that if no pool has been allocated for the object type this call does nothing.
            
            If this type of behaviour is undesirable one may preallocate the pool <see cref="M:VRage.Library.Collections.PoolManager.Preallocate``1(System.Int32)"/>.
            In this case a pre-allocation of size 0 ensures the pool exists but does not allocate any instances.
            </summary>
            <typeparam name="TPooled">The type of the object to return to the pool.</typeparam>
            <param name="obj">An object to return to a pool.</param>
        </member>
        <member name="M:VRage.Library.Collections.PoolManager.BorrowArray``1(System.Int32,``0[]@)">
            <summary>
            Borrow an array.
            </summary>
            <remarks>The array can be returned using the provided handle or <see cref="M:VRage.Library.Collections.PoolManager.ReturnBorrowedArray``1(``0[]@)"/></remarks>
            <typeparam name="TElement">The array element type.</typeparam>
            <param name="size">The minimum size of the requested array, this can be smaller than the actual length.</param>
            <param name="array">The borrowed array, the length of it may be longer than the requested size.</param>
            <returns>A handle that can be used to return the array once it's use is no longer required.</returns>
        </member>
        <member name="M:VRage.Library.Collections.PoolManager.ReturnBorrowedArray``1(``0[]@)">
            <summary>
            Return an array that was borrowed via <see cref="M:VRage.Library.Collections.PoolManager.BorrowArray``1(System.Int32,``0[]@)"/>
            </summary>
            <typeparam name="TElement">The array element type.</typeparam>
            <param name="array"></param>
        </member>
        <member name="M:VRage.Library.Collections.PoolManager.BorrowMemory``1(System.Int32,VRage.Library.Collections.PooledMemory{``0}@)">
            <summary>
            Borrow a memory segment.
            </summary>
            <remarks>The memory can be returned using the provided handle or <see cref="M:VRage.Library.Collections.PoolManager.ReturnBorrowedArray``1(``0[]@)"/></remarks>
            <typeparam name="TElement">The memory element type.</typeparam>
            <param name="size">The minimum size of the requested memory, this can be smaller than the actual length.</param>
            <param name="memory">The borrowed memory, the length of it may be longer than the requested size.</param>
            <returns>A handle that can be used to return the memory once it's use is no longer required.</returns>
        </member>
        <member name="M:VRage.Library.Collections.PoolManager.ReturnBorrowedMemory``1(VRage.Library.Collections.PooledMemory{``0}@)">
            <summary>
            Return a memory segment that was borrowed via <see cref="M:VRage.Library.Collections.PoolManager.BorrowMemory``1(System.Int32,VRage.Library.Collections.PooledMemory{``0}@)"/>
            </summary>
            <typeparam name="TElement">The memory element type.</typeparam>
            <param name="memory"></param>
        </member>
        <member name="M:VRage.Library.Collections.PoolManager.BorrowSpan``1(System.Int32,System.Span{``0}@)">
            <summary>
            Borrow a span of memory containing elements of the requested type.
            </summary>
            <typeparam name="TElement">The array element type.</typeparam>
            <param name="size">The length of the requested span.</param>
            <param name="span">The borrowed span.</param>
            <returns>A token used to return the borrowed memory span.</returns>
        </member>
        <member name="T:VRage.Library.Collections.SmallBitField">
            <summary>
            Bit field with up to 64 bits.
            </summary>
        </member>
        <member name="P:VRage.Library.Collections.StateMap`1.Count">
            <inheritdoc />
        </member>
        <member name="P:VRage.Library.Collections.StateMap`1.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Collections.StateMap`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Collections.StateMap`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="F:VRage.Library.Collections.StateMap`1.ElementBitSize">
            <summary>
            The number of bits required to fully represent a valid instance of the state element.
            </summary>
        </member>
        <member name="F:VRage.Library.Collections.StateMap`1.ElementByteSize">
            <summary>
            The number of bytes required to fully represent a valid instance of the state element.
            </summary>
        </member>
        <member name="F:VRage.Library.Collections.StateMap`1.ElementMask">
            <summary>
            Mask that can be used to select all the relevant bits from a valid value.
            </summary>
        </member>
        <member name="F:VRage.Library.Collections.StateMap`1.IsSigned">
            <summary>
            Whether the underlying type of the state enum is signed.
            </summary>
        </member>
        <member name="F:VRage.Library.Collections.StateMap`1.IsFlags">
            <summary>
            Whether the element enum is annotated with <see cref="T:System.FlagsAttribute"/>
            </summary>
        </member>
        <member name="T:VRage.Library.FastPriorityQueue`1">
            <summary>
            An implementation of a min-Priority Queue using a heap.  Has O(1) .Contains()!
            See https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp/wiki/Getting-Started for more information
            </summary>
            <typeparam name="T">The values in the queue.  Must extend the FastPriorityQueueNode class</typeparam>
            
            <inheritdoc />
        </member>
        <member name="F:VRage.Library.FastPriorityQueue`1.Node.Priority">
            <summary>
            The Priority to insert this node at.  Must be set BEFORE adding a node to the queue (ideally just once, in the node's constructor).
            Should not be manually edited once the node has been enqueued - use queue.UpdatePriority() instead
            </summary>
        </member>
        <member name="F:VRage.Library.FastPriorityQueue`1.Node.QueueIndex">
            <summary>
            Represents the current position in the queue
            </summary>
        </member>
        <member name="M:VRage.Library.FastPriorityQueue`1.#ctor(System.Int32)">
            <summary>
            Instantiate a new Priority Queue
            </summary>
            <param name="maxNodes">The max nodes ever allowed to be enqueued (going over this will cause undefined behavior)</param>
        </member>
        <member name="P:VRage.Library.FastPriorityQueue`1.Count">
            <summary>
            Returns the number of nodes in the queue.
            O(1)
            </summary>
        </member>
        <member name="P:VRage.Library.FastPriorityQueue`1.MaxSize">
            <summary>
            Returns the maximum number of items that can be enqueued at once in this queue.  Once you hit this number (ie. once Count == MaxSize),
            attempting to enqueue another item will cause undefined behavior.  O(1)
            </summary>
        </member>
        <member name="M:VRage.Library.FastPriorityQueue`1.Clear">
            <summary>
            Removes every node from the queue.
            O(n) (So, don't do this often!)
            </summary>
        </member>
        <member name="M:VRage.Library.FastPriorityQueue`1.Contains(`0)">
            <summary>
            Returns (in O(1)!) whether the given node is in the queue.  O(1)
            </summary>
        </member>
        <member name="M:VRage.Library.FastPriorityQueue`1.Enqueue(`0,System.Int64)">
            <summary>
            Enqueue a node to the priority queue.  Lower values are placed in front. Ties are broken arbitrarily.
            If the queue is full, the result is undefined.
            If the node is already enqueued, the result is undefined.
            O(log n)
            </summary>
        </member>
        <member name="M:VRage.Library.FastPriorityQueue`1.HasHigherOrEqualPriority(`0,`0)">
            <summary>
            Returns true if 'higher' has higher priority than 'lower', false otherwise.
            Note that calling HasHigherOrEqualPriority(node, node) (ie. both arguments the same node) will return true
            </summary>
        </member>
        <member name="M:VRage.Library.FastPriorityQueue`1.Dequeue">
            <summary>
            Removes the head of the queue and returns it.
            If queue is empty, result is undefined
            O(log n)
            </summary>
        </member>
        <member name="M:VRage.Library.FastPriorityQueue`1.Resize(System.Int32)">
            <summary>
            Resize the queue so it can accept more nodes.  All currently enqueued nodes are remain.
            Attempting to decrease the queue size to a size too small to hold the existing nodes results in undefined behavior
            O(n)
            </summary>
        </member>
        <member name="P:VRage.Library.FastPriorityQueue`1.First">
            <summary>
            Returns the head of the queue, without removing it (use Dequeue() for that).
            If the queue is empty, behavior is undefined.
            O(1)
            </summary>
        </member>
        <member name="M:VRage.Library.FastPriorityQueue`1.UpdatePriority(`0,System.Int64)">
            <summary>
            This method must be called on a node every time its priority changes while it is in the queue.  
            <b>Forgetting to call this method will result in a corrupted queue!</b>
            Calling this method on a node not in the queue results in undefined behavior
            O(log n)
            </summary>
        </member>
        <member name="M:VRage.Library.FastPriorityQueue`1.Remove(`0)">
            <summary>
            Removes a node from the queue.  The node does not need to be the head of the queue.  
            If the node is not in the queue, the result is undefined.  If unsure, check Contains() first
            O(log n)
            </summary>
        </member>
        <member name="M:VRage.Library.FastPriorityQueue`1.IsValidQueue">
            <summary>
            <b>Should not be called in production code.</b>
            Checks to make sure the queue is still in a valid state.  Used for testing/debugging the queue.
            </summary>
        </member>
        <member name="M:VRage.Library.Debugging.MyTimedStatWindow.IntArithmeticImpl.Add(System.Int32@,System.Int32@,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Debugging.MyTimedStatWindow.IntArithmeticImpl.Subtract(System.Int32@,System.Int32@,System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Debugging.MyTimedStatWindow.FloatArithmeticImpl.Add(System.Single@,System.Single@,System.Single@)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Debugging.MyTimedStatWindow.FloatArithmeticImpl.Subtract(System.Single@,System.Single@,System.Single@)">
            <inheritdoc />
        </member>
        <member name="T:VRage.Library.Debugging.MyTimedStatWindow`1">
            <summary>
            Fixed time sliding window. Useful for debug statistics.
            </summary>
            <typeparam name="TStats"></typeparam>
        </member>
        <member name="M:VRage.Library.Debugging.MyTimedStatWindow`1.#ctor(System.TimeSpan,System.Func{`0,`0,`0},System.Func{`0,`0,`0})">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Debugging.MyTimedStatWindow`1.Advance">
            <summary>
            
            </summary>
        </member>
        <member name="M:VRage.Library.Debugging.MyTimedStatWindow`1.FuncArithmetic.Add(`0@,`0@,`0@)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Debugging.MyTimedStatWindow`1.FuncArithmetic.Subtract(`0@,`0@,`0@)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Debugging.MyTimedStatWindow`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Debugging.MyTimedStatWindow`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:VRage.Library.Extensions.ExpressionBaseActivatorFactory">
            <summary>
            Activator factory that uses expression trees.
            </summary>
            <remarks>This is the default activator factory.</remarks>
        </member>
        <member name="M:VRage.Library.Extensions.ExpressionBaseActivatorFactory.CreateActivator``1">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Extensions.ExpressionBaseActivatorFactory.CreateActivator``1(System.Type)">
            <inheritdoc />
        </member>
        <member name="T:VRage.Library.Extensions.IActivatorFactory">
            <summary>
            Interface describing a factory for activators.
            </summary>
        </member>
        <member name="M:VRage.Library.Filesystem.ContentIndex.FileExists(System.String)">
            <summary>
            Whether a file is expected to exist in the content directory.
            </summary>
            <param name="contentPath"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.NativeArray.AsSpan``1(System.Int32)">
            <summary>
            Get the contents of this array as a span.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.NativeArray.AsSpan(System.Int32)">
            <summary>
            Get the contents of this array as a byte span.
            </summary>
            <returns></returns>
        </member>
        <member name="T:VRage.Library.Net.CircularMapping">
            <summary>
            Allows easy mapping of a circular buffer onto a linear range.
            </summary>
            <returns>
            The buffer defines an <i>Active Segment</i>, a range of values delimited by <see cref="F:VRage.Library.Net.CircularMapping.Head"/> and <see cref="F:VRage.Library.Net.CircularMapping.Tail"/>.
            this active segment can 
            </returns>
        </member>
        <member name="M:VRage.Library.Net.CircularMapping.#ctor(System.Int32)">
            <summary>
            Create a new circular buffer representation with a given length.
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:VRage.Library.Net.CircularMapping.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create a new circular buffer representation with a given length.
            </summary>
            <param name="capacity"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:VRage.Library.Net.CircularMapping.Copy`1" -->
        <member name="M:VRage.Library.Net.CircularMapping.ResizeBuffer``1(System.Int32,``0,``0,VRage.Library.Net.CircularMapping.Copy{``0})">
            <summary>
            Resize this mapping and copy user data the data to a resized buffer to match.
            </summary>
            <typeparam name="TBuffer">The type of the user buffer.</typeparam>
            <param name="newLength">The new length of the circular mapping.</param>
            <param name="original">The original buffer.</param>
            <param name="resized">The new buffer that is correctly sized.</param>
        </member>
        <member name="M:VRage.Library.Net.CircularMapping.Resize(System.Int32)">
            <summary>
            Resize the virtual length of the circular mapping.
            </summary>
            <param name="newLength"></param>
        </member>
        <member name="M:VRage.Library.Net.CircularMapping.AdvanceHead(System.Int32)">
            <summary>
            Advance the head, shrinking the active segment.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.CircularMapping.AdvanceTail(System.Int32)">
            <summary>
            Advance the tail, extending the active segment.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.CircularMapping.Advance(System.Int32)">
            <summary>
            Advance the provided index to the next valid position in the circular buffer.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.CircularMapping.Advance(System.Int32,System.Int32)">
            <summary>
            Advance the provided index to the next valid position in the circular buffer.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.CircularMapping.Retract(System.Int32,System.Int32)">
            <summary>
            Retract the provided index to a previous valid position in the circular buffer.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.CircularMapping.Retract(System.Int32)">
            <summary>
            Advance the provided index to the next valid position in the circular buffer.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.CircularMapping.Distance(System.Int32,System.Int32)">
            <summary>
            Calculate the number of entries between the two positions in the circular buffer.
            </summary>
            <remarks>This method will prefer returning zero over <see cref="F:VRage.Library.Net.CircularMapping.Capacity"/> if the positions are equal.</remarks>
            <param name="from"></param>
            <param name="to"></param>
            <returns>The distance between the positions.</returns>
        </member>
        <member name="M:VRage.Library.Net.CircularMapping.IsInRange(System.Int32)">
            <summary>
            Whether <paramref name="index"/> is within the bounds of the active range in the circular buffer.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.CircularMapping.IsInRange(System.Int32,System.Int32,System.Int32)">
            <summary>
            Whether a given index is contained in the provided range on the circular buffer.
            </summary>
            <remarks>This method assumes that the index is valid, and therefore it does not need to know the size of the list.
            It also assumes the list does not envelop the entire buffer.</remarks>
            <param name="start">The start index.</param>
            <param name="end">The end index.</param>
            <param name="position">The index to query/</param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.CircularMapping.EnumerateActiveSegment">
            <summary>
            Enumerate all frames in the occupied section of the sliding window.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.CircularMapping.EnumerateRange(System.Int32,System.Int32)">
            <summary>
            Enumerate all frames in the user provided range.
            </summary>
            <remarks>If <paramref name="start"/> == <paramref name="end"/> the enumeration yields no results.
            To enumerate a full circle see <see cref="M:VRage.Library.Net.CircularMapping.EnumerateFullRange(System.Int32)"/>.</remarks>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.CircularMapping.EnumerateFullRange(System.Int32)">
            <summary>
            Enumerate all frames in the mapping, starting at <paramref name="start"/>.
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.CircularMapping.Enumerable.System#Collections#Generic#IEnumerable{System#Int32}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.CircularMapping.Enumerable.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:VRage.Library.Net.CircularMapping.Enumerator">
            <summary>
            Enumerate the indices belonging to a range in a circular buffer.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.CircularMapping.Enumerator.m_notEmpty">
            <summary>
            Double negative ensured default(RingEnumerator) is empty.
            </summary>
        </member>
        <member name="P:VRage.Library.Net.CircularMapping.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.CircularMapping.Enumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="T:VRage.Library.Net.DefaultQoSProvider">
            <summary>
            Default implementation of a Quality of Service Provider.
            </summary>
            <remarks>
            <para>
            This implementation supports:
            <ul>
                <li>Reliability for undelivered, out of order and duplicate messages.</li>
                <li>Sliding window to maintain bandwidth when latency is high.</li>
                <li>Message coalescing to reduce the number of transmissions when messages are sufficiently smaller than the MTU size.</li>
                <li>Message fragmentation to allow for streaming messages larger then the MTU size.</li>
            </ul>
            It does not, however, support:
            <ul>
                <li>Response to variable MTU size.</li>
                <li>Encryption.</li>
                <li>Reliability for tampered or incomplete messages.</li>
            </ul>
            </para>
            <h3>Terminology</h3>
            <para>
            To reduce confusion we use the following terminology:
            <ul>
                <li>Frame: A complete packet send to underlying unreliable transport.</li>
                <li>Message: An individual message as provided by the user.</li>
            </ul>
            <b>Importantly</b>: One frame may contain multiple small messages and a large message may span multiple frames.
            </para>
            <h3>Queuing</h3>
            <para>
            When a frame is ready for sending but the sliding window is full it gets queued. The same happens if we the
            sliding window for received frames advances but not all messages from the processed frames are read.
            </para><para>
            These queues are in the same memory block as the sliding window itself and advance with it.
            </para><para>
            If the queue get's full we increase it's size up to the user provided maximum. After that we will no longer
            process remote message frames when the receive queue is full, and will block the caller until the window
            advances on the sending queue.
            </para>
            <h3>Message Formats</h3>
            <ul>
                <li>Message: Message frames start with a non-zero sequence number, after that comes a sequence of messages.
            Each message has a header containing the channel and size. Messages may span multiple frames, in that case the
            following frame will not contain a message header, just the remainder of the data. This repeats for as many
            frames as required to send the entire message.</li>
                <li>Ack: An ack frame starts with a zero sequence number, followed by a frame type corresponding to the Ack
            frame, and by a bitmap representing the state of the remote sliding window.</li>
                
            </ul>
            </remarks>
        </member>
        <member name="T:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1">
            <summary>
            Combined queue and sliding window buffers.
            </summary>
            <typeparam name="THeader">The type of the metadata header.</typeparam>
        </member>
        <member name="P:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.WindowCapacity">
            <summary>
            Size of the window portion of the buffer.
            </summary>
        </member>
        <member name="P:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.QueueCapacity">
            <summary>
            Size of the send/receive queue portion of the buffer.
            </summary>
        </member>
        <member name="P:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.TotalCapacity">
            <summary>
            Total capacity of this sliding window.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.Rescale(System.Int32)">
            <summary>
            Adjust the size of the sliding window versus the queue size while maintaining the total size constant.
            </summary>
            <param name="newWindowSize">new size ofr the window portion of the buffer.</param>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.Resize(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Resize this sliding window.
            </summary>
            <param name="windowSize">The new maximum window size.</param>
            <param name="queueSize">The new maximum queue size.</param>
        </member>
        <member name="T:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.BufferSet">
            <summary>
            Helper struct for buffer reallocation.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.AdvanceHead(System.Boolean,System.Int32)">
            <summary>
            Advance the head to the next frame, making it valid for processing.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.AdvanceTail(System.Int32)">
            <summary>
            Advance the tail to the next frame, making it ready for re-use.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.Advance(System.Int32)">
            <summary>
            Advance the provided index to the next valid position in the circular buffer.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.Advance(System.Int32,System.Int32)">
            <summary>
            Advance the provided index to the next valid position in the circular buffer.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.Retract(System.Int32)">
            <summary>
            Advance the provided index to the next valid position in the circular buffer.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.Retract(System.Int32,System.Int32)">
            <summary>
            Advance the provided index to the next valid position in the circular buffer.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.Advance(VRage.Library.Net.DefaultQoSProvider.WindowPointer)">
            <summary>
            Advance the provided index to the next valid position in the circular buffer.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.Advance(VRage.Library.Net.DefaultQoSProvider.WindowPointer,System.Int32)">
            <summary>
            Advance the provided index to the next valid position in the circular buffer.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.Distance(System.Int32,System.Int32)">
            <summary>
            Calculate the number of frames between the two positions in the circular buffer.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.Distance(VRage.Library.Net.DefaultQoSProvider.WindowPointer@,System.Int32)">
            <summary>
            Calculate the number of frames between the two positions in the circular buffer.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.Distance(System.Int32,VRage.Library.Net.DefaultQoSProvider.WindowPointer@)">
            <summary>
            Calculate the number of frames between the two positions in the circular buffer.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.Distance(VRage.Library.Net.DefaultQoSProvider.WindowPointer@,VRage.Library.Net.DefaultQoSProvider.WindowPointer@)">
            <summary>
            Calculate the number of frames between the two positions in the circular buffer.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.CalculateSequence(VRage.Library.Net.DefaultQoSProvider.WindowPointer@,System.Int32)">
            <summary>
            Given a start reference pointer and a position in the buffer calculate the sequence number.
            </summary>
            <param name="reference">Point of reference.</param>
            <param name="position">The position to calculate the sequence number for.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.CalculatePosition(VRage.Library.Net.DefaultQoSProvider.WindowPointer@,System.UInt32)">
            <summary>
            Calculate the position of a frame given a point of reference and it's sequence number.
            </summary>
            <param name="reference"></param>
            <param name="sequenceNumber"></param>
            <returns></returns>
        </member>
        <member name="P:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.Item(System.Int32)">
            <summary>
            Get the hea
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.GetFrame(System.Int32)">
            <summary>
            Get a span representing the memory range for a given frame.
            </summary>
            <param name="frameIndex">The index of the frame.</param>
            <returns>The memory range where the frame is stored.</returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.CombinedBuffer`1.EnumerateFrames(System.Int32,System.Int32)">
            <summary>
            Enumerate all frames in the user provided range.
            </summary>
            <remarks>This method assumes start and end may never be the same.</remarks>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="T:VRage.Library.Net.DefaultQoSProvider.WindowPointer">
            <summary>
            Pointer to a frame in the sliding window.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.WindowPointer.Sequence">
            <summary>
            Frame sequence number.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.WindowPointer.Position">
            <summary>
            Position in the window.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_lastSentControlSequence">
            <summary>
            Use a separate sequence number for control frames.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_lastReceivedControlSequence">
            <summary>
            Last sent sequence number for a Ping frame.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.TraceControlFrames">
            <summary>
            Whether to include ping messages in the trace.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.GetNewControlFrame(VRage.Library.Net.DefaultQoSProvider.FrameType,System.Span{System.Byte}@)">
            <summary>
            Start a new control frame of given type.
            </summary>
            <remarks>Control frames are recorded using <see cref="F:VRage.Library.Net.DefaultQoSProvider.m_controlBuffer"/>, make sure to never start two control frames simultaneously.</remarks>
            <param name="type">The type of the control frame.</param>
            <param name="frameData">The frame data.</param>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.ProcessControlFrame(VRage.Library.Net.DefaultQoSProvider.FrameHeader@,System.Span{System.Byte})">
            <summary>
            Process a control frame received from the remote.
            </summary>
            <param name="header">The header for the frame.</param>
            <param name="frameData">The frame data including the header.</param>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.SendControlFrame(System.Span{System.Byte},VRage.Library.Net.DefaultQoSProvider.FrameType)">
            <summary>
            Send a message frame to the remote.
            </summary>
            <param name="frame"></param>
            <param name="type"></param>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.ProcessAckControl(System.Span{System.Byte})">
            <summary>
            Process an ack control frame.
            </summary>
            <param name="frameData"></param>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.SendAckControl(System.Span{System.Byte})">
            <summary>
            Send a frame acknowledging a given received control frame.
            </summary>
            <param name="originalControlFrame"></param>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_averageEstimateRtt">
            <summary>
            Calculated by an exponential moving average of the last few samples.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_averageEstimateRttVariation">
            <summary>
            Calculated by an exponential moving average of the last few samples.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_lastSentPingTime">
            <summary>
            Timestamp of the last sent ping.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_lastReceivedPingTime">
            <summary>
            Timestamp of the last sent ping.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.MinPingInterval">
            <summary>
            Minimum interval between pings.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.MinPing">
            <summary>
            Minimum ping value we accept to use.
            </summary>
            <remarks>This allows us to protect against explosive packet transfers on the same network or machine.</remarks>
        </member>
        <member name="P:VRage.Library.Net.DefaultQoSProvider.EstimateRTT">
            <summary>
            Estimated Round-Trip-Time.
            </summary>
        </member>
        <member name="P:VRage.Library.Net.DefaultQoSProvider.EstimateRTTVariation">
            <summary>
            Variation in the Estimated Round-Trip-Time.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.CheckAndSendPing">
            <summary>
            Check whether it's time to send a ping, and if so send it.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.SendPing">
            <summary>
            Send a ping frame to the remote.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.ProcessPing(System.Span{System.Byte})">
            <summary>
            Process a received ping frame.
            </summary>
            <param name="frameData"></param>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.ProcessAckPing(System.Span{System.Byte})">
            <summary>
            Process a bounced back ping frame.
            </summary>
            <param name="pingFrameData"></param>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.UpdateRtt(System.TimeSpan)">
            <summary>
            Calculate a new updated average RTT based on a new estimate.
            </summary>
            <param name="elapsed"></param>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.NativeArrayAllocator">
            <summary>
            Allocator for all the native arrays.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_settings">
            <summary>
            Settings for the current sliding window.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_controlBuffer">
            <summary>
            Buffer used to read and write control messages.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_transport">
            <summary>
            The underlying transport.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_time">
            <summary>
            Our time counter.
            </summary>
        </member>
        <member name="P:VRage.Library.Net.DefaultQoSProvider.MaxNonBlockingMessageSize">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.ProcessReadQueues">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.ProcessWriteQueues">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.GetTime">
            <summary>
            Get the current relative time.
            </summary>
            <remarks>This is only ever used to time RTT and to determine packet re-send timeouts, therefore we don't need universal time.</remarks>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.TimedOut">
            <summary>
            We waited too long and the remote host has not replied or sending a particular packet has failed too many times.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.ComputeResize(System.Int32,System.Int32,System.Int32)">
            <summary>
            Compute the ideal new size for an object given the current, desired, and maximum values.
            </summary>
            <returns>
            This method assumes the desired size is not larger than the maximum size.
            It also attempts to emulate the amortized constant time, quadratic scaling method commonly used for vectors/lists.
            </returns>
            <param name="current">Current size of the object.</param>
            <param name="max">Maximum size of the object.</param>
            <param name="desired">Desired size.</param>
            <returns>The computed size.</returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.UpdateAverage(System.TimeSpan,System.TimeSpan,System.Single)">
            <summary>
            Update an exponential moving average with a new value.
            </summary>
            <param name="average"></param>
            <param name="newValue"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.Max(System.TimeSpan,System.TimeSpan)">
            <summary>
            Return the timespan with the highest tick count between the arguments.
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="P:VRage.Library.Net.DefaultQoSProvider.Settings">
            <summary>
            Get a copy of the settings used by this provider.
            </summary>
        </member>
        <member name="T:VRage.Library.Net.DefaultQoSProvider.InitSettings">
            <summary>
            Settings for a sliding window in a user friendly format.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.InitSettings.MinimumWindowSize">
            <summary>
            Minimum number of bytes to hold in the sliding window.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.InitSettings.MaximumWindowSize">
            <summary>
            Maximum number of bytes to hold in the sliding window.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.InitSettings.MinimumQueueSize">
            <summary>
            Minimum size of the send/receive queues.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.InitSettings.MaximumQueueSize">
            <summary>
            Maximum size of the send/receive queues.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.InitSettings.MaximumMessageSize">
            <summary>
            Maximum size for a oversized message.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.InitSettings.InitialSequenceNumber">
            <summary>
            Initial value for the sequence number.
            </summary>
            <remarks>Use this with care. Make sure the remote end chooses the same number, otherwise they will not be able to communicate.</remarks>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.InitSettings.DisconnectTimeout">
            <summary>
            Time to wait without a successful transmission before throwing an exception.
            </summary>
            <returns>This will happen when the send queue is full but we cannot get an ack for the frames in the active sliding window.</returns>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.InitSettings.ClearBuffers">
            <summary>
            Clear buffers after every use.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.InitSettings.FrameTimeoutSlipFactor">
            <summary>
            Factor applied to the estimated RTT to arrive at the frame timeout time.
            </summary>
            <remarks>This value must be greater than or equal to 1 and must be chosen very carefully.</remarks>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.InitSettings.WindowGrowthFactor">
            <summary>
            Factor used to grow the sliding window by over time.
            </summary>
            <remarks>This value must be greater than 1 and must be chosen very carefully.</remarks>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.InitSettings.FrameLossTolerance">
            <summary>
            Maximum acceptable packet loss before the window starts to shrink.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.InitSettings.WindowAdjustmentThreshold">
            <summary>
            Minimum number of frames to consider before adjusting the sliding window size.
            </summary>
            <remarks>
            The window will still adjust only as often as the frame timeout, this setting
            simply adds a second limit so that the window does not try to adjust when only
            a handful of messages are being transferred per second.
            </remarks>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.InitSettings.Default">
            <summary>
            Default sliding window settings.
            </summary>
        </member>
        <member name="T:VRage.Library.Net.DefaultQoSProvider.ProcessedSettings">
            <summary>
            Represents the provider setting in a ready to use format.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.ProcessedSettings.MinimumWindowCapacity">
            <summary>
            Minimum number of frames to hold in the sliding window.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.ProcessedSettings.MaximumWindowCapacity">
            <summary>
            Maximum number of frames to hold in the sliding window.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.ProcessedSettings.MinimumQueueCapacity">
            <summary>
            Minimum size of the send/receive queues.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.ProcessedSettings.MaximumQueueCapacity">
            <summary>
            Maximum size of the send/receive queues.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.ProcessedSettings.MaximumNonBlockingMessageSize">
            <summary>
            Maximum size in bytes of a message that could be sent by the QoS provider without blocking.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.ProcessedSettings.DisconnectTimeout">
            <summary>
            Time to wait without a successful transmission before throwing an exception.
            </summary>
            <returns>This will happen when the send queue is full but we cannot get an ack for the frames in the active sliding window.</returns>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.ProcessedSettings.ClearBuffers">
            <summary>
            Clear buffers after every use.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.ProcessedSettings.FrameTimeoutSlipFactor">
            <summary>
            Factor applied to the estimated RTT to arrive at the frame timeout time.
            </summary>
            <remarks>This value must be greater than or equal to 1 and must be chosen very carefully.</remarks>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.ProcessedSettings.WindowAdjustmentThreshold">
            <summary>
            Minimum number of frames to consider before adjusting the sliding window size.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.ProcessedSettings.WindowGrowthFactor">
            <summary>
            Factor used to grow the sliding window by over time.
            </summary>
            <remarks>This value must be greater than 1 and must be chosen very carefully.</remarks>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.ProcessedSettings.FrameLossTolerance">
            <summary>
            Maximum acceptable packet loss before the window starts to shrink.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.ProcessedSettings.Create(VRage.Library.Net.DefaultQoSProvider.InitSettings@,VRage.Library.Net.IUnreliableTransportChannel)">
            <summary>
            Create a set of processed setting form a raw instance and transport.
            </summary>
            <param name="settings"></param>
            <param name="transport"></param>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.Dispose">
            <inheritdoc />
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_receivingBuffer">
            <summary>
            Sliding window of frames received from the remote host.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_receivingWindowHead">
            <summary>
            Pointer to the first frame in the sliding window that is missing.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_receivedFrameCursor">
            <summary>
            Cursor into the oldest unprocessed message frame.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_lastAckSent">
            <summary>
            Last Ack packet send time.
            </summary>
        </member>
        <member name="P:VRage.Library.Net.DefaultQoSProvider.MessagesAvailable">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.TryReceiveMessage(System.Span{System.Byte}@,System.Byte@)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.TryPeekMessage(System.Int32@,System.Byte@)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.IsComplete(System.Int32,System.UInt32,System.Int32)">
            <summary>
            Whether a given message is fully available given the current set of available frames.
            </summary>
            <param name="messageStartOffset">Offset to the start of the message contents.</param>
            <param name="messageSize">The size of the message.</param>
            <param name="headerLength">The number of bytes occupied by the message header./</param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.PollAvailableFrames">
            <summary>
            Pulls the waiting frames out of the unreliable network and stores it properly.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.ReceiveMessageFrame(VRage.Library.Net.DefaultQoSProvider.FrameHeader,System.Span{System.Byte})">
            <summary>
            Process a received message frame.
            </summary>
            <param name="header"></param>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.ResizeReceivingBuffer(System.Int32,System.Int32)">
            <summary>
            Resize the receiving buffer and update pointers.
            </summary>
            <remarks>All pointers into the buffer become invalid after this call.</remarks>
            <param name="windowCapacity"></param>
            <param name="queueCapacity"></param>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.WriteAckFrame(System.Span{System.Byte}@)">
            <summary>
            Write an ack frame.
            </summary>
            <param name="frame"></param>
            <param name="frameWriteHead"></param>
        </member>
        <member name="P:VRage.Library.Net.DefaultQoSProvider.ReceivedFrame.IsUnused">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.ReceivedFrame.FormatDebug(VRage.Library.Net.DefaultQoSProvider.FrameHeader)">
            <inheritdoc />
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.FrameTimeout">
            <summary>
            Timeout to use for frame resending.
            </summary>
            <remarks>While RTT is still not calculated we will use the minimum ping interval.</remarks>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_sendingBuffer">
            <summary>
            Sliding window for frames destined to the remote host.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_unsentFrameCursor">
            <summary>
            Write cursor into the last unsent frame.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_nextResendFrame">
            <summary>
            Index of the next frame we'll be resending once it times out.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_sendingHead">
            <summary>
            Pointer to the oldest frame in the sliding window.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_firstSendQueueFrame">
            <summary>
            Position of the first frame in the send queue.
            </summary>
        </member>
        <member name="P:VRage.Library.Net.DefaultQoSProvider.HasPendingDeliveries">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.SendMessage(System.Span{System.Byte},System.Byte,VRage.Library.Net.SendMessageFlags)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.GetNextFrame(VRage.Library.Net.DefaultQoSProvider.FrameInfo@)">
            <summary>
            Get the data for the message frame that is under construction and is the next to be sent.
            </summary>
            <param name="frame"></param>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.GetNewFrame(VRage.Library.Net.DefaultQoSProvider.FrameInfo@,System.Boolean)">
            <summary>
            Get a new message frame to start assembling.
            </summary>
            <param name="frame"></param>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.FinishFrame(VRage.Library.Net.DefaultQoSProvider.FrameInfo@)">
            <summary>
            Finish and send a frame to the remote client.
            </summary>
            <param name="frame"></param>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.SendFrame(System.Int32)">
            <summary>
            Send a finished frame to the remote host.
            </summary>
            <param name="framePosition">The index of the frame to send.</param>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.ResizeSendingBuffer(System.Int32,System.Int32)">
            <summary>
            Resize the receiving buffer and update pointers.
            </summary>
            <remarks>All pointers into the buffer become invalid after this call.</remarks>
            <param name="windowCapacity"></param>
            <param name="queueCapacity"></param>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.ProcessSendQueueBlocking">
            <summary>
            Work on the send queue until at least one frame becomes available.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.ProcessSendQueue(System.Boolean)">
            <summary>
            Process the send queue for frames that might need to be sent for the first time or re-sent due to timing out.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.ShouldResend(VRage.Library.Net.DefaultQoSProvider.SendingFrame@,System.TimeSpan@)">
            <summary>
            Whether the frame identified by the provided header should be resent.
            </summary>
            <param name="header"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.HasRetriedTooManyTimes(VRage.Library.Net.DefaultQoSProvider.SendingFrame@)">
            <summary>
            Whether a frame was re-tried too many times.
            </summary>
            <param name="header">The frame header.</param>
            <returns>True if the frame was retired too many times. False otherwise.</returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.FindNextResendFrame">
            <summary>
            Find the index for the next frame that is missing in the sliding window
            </summary>
            <param name="missingFramePosition"></param>
            <returns></returns>
        </member>
        <member name="P:VRage.Library.Net.DefaultQoSProvider.AverageAckTime">
            <summary>
            Average time between a message being sent and it being acknowledged.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.ProcessAcks(System.Span{System.Byte})">
            <summary>
            Process an ack frame.
            </summary>
            <param name="ackMessage"></param>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_framesSent">
            <summary>
            Total number of frames sent (successfully or not) since the last window resize.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_framesLost">
            <summary>
            Number of frames lost since the last window resize.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_maxWindowSize">
            <summary>
            Maximum window length since the last adjustment.
            </summary>
            <remarks>This is used to prevent idle connections from reaching maximum window size unnecessarily.</remarks>
        </member>
        <member name="P:VRage.Library.Net.DefaultQoSProvider.FrameLoss">
            <summary>
            Ratio of frames lost.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_targetSendingWindowCapacity">
            <summary>
            The target size for the sending window capacity.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_windowGrowthFactor">
            <summary>
            Growth factor for the sliding window. Adjusted based on packet loss.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_timeSinceLastWindowAdjustment">
            <summary>
            Time since we last attempted to adjust the window size.
            </summary>
        </member>
        <member name="P:VRage.Library.Net.DefaultQoSProvider.SlidingWindowSize">
            <summary>
            Current size of the sending sliding window.
            </summary>
        </member>
        <member name="P:VRage.Library.Net.DefaultQoSProvider.QueueSize">
            <summary>
            Current size of the sending queue window.
            </summary>
        </member>
        <member name="T:VRage.Library.Net.DefaultQoSProvider.SendingFrame">
            <summary>
            Represents a frame we will be sending.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.SendingFrame.State">
            <summary>
            State of the frame.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.SendingFrame.LastSentTime">
            <summary>
            Last time we sent this frame.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.SendingFrame.EnqueueTime">
            <summary>
            Last time we sent this frame.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.SendingFrame.Length">
            <summary>
            The length of the frame.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.SendingFrame.SetAcknowledged">
            <summary>
            Move the frame to the Acknowledged state.
            </summary>
        </member>
        <member name="P:VRage.Library.Net.DefaultQoSProvider.SendingFrame.IsUnused">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.SendingFrame.FormatDebug(VRage.Library.Net.DefaultQoSProvider.FrameHeader)">
            <inheritdoc />
        </member>
        <member name="T:VRage.Library.Net.DefaultQoSProvider.SendState">
            <summary>
            State for a frame on the sending sliding window.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.SendState.Acknowledged">
            <summary>Frame has been acknowledged/is not used.</summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.SendState.Unfinished">
            <summary>Frame is being written and is not finished.</summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.SendState.Queued">
            <summary>Frame was put on the sending queue.</summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.SendState.Sent">
            <summary>Frame was sent to the remote host.</summary>
        </member>
        <member name="T:VRage.Library.Net.DefaultQoSProvider.FrameInfo">
            <summary>
            Represents all the logical information about a message frame.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.FrameInfo.FramePosition">
            <summary>
            Index of the frame in the sliding window.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.FrameInfo.Sequence">
            <summary>
            Sequence number for the frame.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.FrameInfo.Data">
            <summary>
            The frame's raw data.
            </summary>
        </member>
        <member name="T:VRage.Library.Net.DefaultQoSProvider.FrameType">
            <summary>
            Enum describing the types of control frames.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.FrameType.Message">
            <summary>This frame contains one or more messages.</summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.FrameType.AckControl">
            <summary>This frame Acknowledges a given control message.</summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.FrameType.Ack">
            <summary>This frame contains a sequence of bits that represents which frames the remote currently has received.</summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.FrameType.Ping">
            <summary>Ping frames are used to calculate RTT.</summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.Write``1(System.Span{System.Byte},``0@)">
            <summary>
            Write a given struct to the provided memory range.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.WriteMessage(VRage.Library.Net.DefaultQoSProvider.MessageHeader@,System.Span{System.Byte},System.Int32@,System.Span{System.Byte})">
            <summary>
            Write a message to the given frame.
            </summary>
            <remarks>
            This method will only write the number of bytes that fit into the current frame.
            </remarks>
            <param name="header"></param>
            <param name="frame">The frame to write the message to.</param>
            <param name="frameWriteHead">The current frame write head.
            Upon returning this will be the new position on the first byte after the message ends.</param>
            <param name="message">The message to write.</param>
            <returns>The number of message bytes written. This can be zero if the only the header fits the current frame.</returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.Access``1(System.Span{System.Byte})">
            <summary>
            Get a reference to the given range in a span interpreted as an instance of <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type to reinterpret the memory range as.</typeparam>
            <param name="dataRange">The range of memory containing the type instance.</param>
            <returns>A reference to the reinterpreted memory range.</returns>
        </member>
        <member name="T:VRage.Library.Net.DefaultQoSProvider.FrameHeader">
            <summary>
            Basic frame header.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.FrameHeader.Size">
            <summary>
            Number of bytes occupied by this struct.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.FrameHeader.Sequence">
            <summary>
            Sequence number.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.FrameHeader.Type">
            <summary>
            The type of the frame.
            </summary>
        </member>
        <member name="T:VRage.Library.Net.DefaultQoSProvider.AckFrameHeader">
            <summary>
            Header for the ack frame.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.AckFrameHeader.Size">
            <summary>
            Number of bytes occupied by this struct.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.AckFrameHeader.FrameHeader">
            <summary>
            Base Header.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.AckFrameHeader.FirstMissingSequence">
            <summary>
            Sequence number for the first frame the remote knows it has not received.
            </summary>
        </member>
        <member name="T:VRage.Library.Net.DefaultQoSProvider.PingFrame">
            <summary>
            Layout of the ping frame.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.PingFrame.Size">
            <summary>
            Number of bytes occupied by this struct.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.PingFrame.FrameHeader">
            <summary>
            Base Header.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.PingFrame.Timestamp">
            <summary>
            Timestamp for the original sending of this message.
            </summary>
        </member>
        <member name="T:VRage.Library.Net.DefaultQoSProvider.MessageHeader">
            <summary>
            Struct representing a message header.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.MessageHeader.Channel">
            <summary>
            The channel the message is sent through.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.MessageHeader.Length">
            <summary>
            Sequence number.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.MessageHeader.MaxSize">
            <summary>
            Maximum size for a message header.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.MessageHeader.Fits(System.Int32)">
            <summary>
            Whether this message header fits in the available space.
            </summary>
            <param name="space"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.MessageHeader.Size">
            <summary>
            Calculate the size of this message header.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.MessageHeader.Read(System.Span{System.Byte},System.Int32@)">
            <summary>
            Read a message header from a memory range.
            </summary>
            <param name="frame">The range where the memory is stored.</param>
            <param name="headerLength">The length the header occupied.</param>
            <returns></returns>
        </member>
        <member name="T:VRage.Library.Net.DefaultQoSProvider.Variant">
            <summary>
            Utilities for encoding numbers in a variable length format.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.Variant.Uint32MaximumEncodedLength">
            <summary>
            Maximum length for a valid Variant-encoded Uint32.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.Variant.ReadVariant(System.Span{System.Byte},System.UInt32@)">
            <summary>
            Read a variant from the provided source range and store it in <paramref name="value"/>.
            </summary>
            <param name="source">The memory range containing the variant to be decoded.</param>
            <param name="value">The decoded value.</param>
            <returns>The number of bytes the encoded representation occupied.</returns>
            <exception cref="T:System.OverflowException">If the encoded value would overflow the capacity of a <c>uint</c>.</exception>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.Variant.WriteVariant(System.UInt32,System.Span{System.Byte})">
            <summary>
            Writes a variant to the provided memory chunk.
            </summary>
            <param name="value">The value to write as a variant</param>
            <param name="destination">The memory range where to store the result.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.Variant.CalcEncodedLength(System.UInt32)">
            <summary>
            Calculate how many bytes it would take to write a given unsigned value as a variant.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="F:VRage.Library.Net.DefaultQoSProvider.m_statistics">
            <summary>
            Stats instance.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.GetStatistics">
            <summary>
            Get the current statistics tracker, if any.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.SetStatisticsTracker(VRage.Library.Net.DefaultQoSProvider.Statistics)">
            <summary>
            Se the statistics tracker for this instance.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="T:VRage.Library.Net.DefaultQoSProvider.Statistics">
            <summary>
            Statistics tracker used by the Default QoS provider.
            </summary>
            <remarks>Statistics trackers can be shared between multiple instances.</remarks>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.Statistics.AddTo(VRage.Library.Net.DefaultQoSProvider.Statistics)">
            <summary>
            Add all of the values of this instance into another.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.Statistics.CreateAbsolute">
            <summary>
            Create a statistics object that tracks an absolute total.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.Statistics.CreateMovingWindow(System.TimeSpan)">
            <summary>
            Create a statistics object that tracks the total traffic during a moving window of time with provided length.
            </summary>
            <param name="windowLength">Length of time to collect traffic for.</param>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.Statistics.SentTraffic.op_Addition(VRage.Library.Net.DefaultQoSProvider.Statistics.SentTraffic@,VRage.Library.Net.DefaultQoSProvider.Statistics.SentTraffic@)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.Statistics.SentTraffic.op_Subtraction(VRage.Library.Net.DefaultQoSProvider.Statistics.SentTraffic@,VRage.Library.Net.DefaultQoSProvider.Statistics.SentTraffic@)">
            <inheritdoc />
        </member>
        <member name="T:VRage.Library.Net.DefaultQoSProvider.Statistics.SentTraffic.Acknowledgement">
            <summary>
            Statistics for message acknowledgement times.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.Statistics.ReceivedTraffic.op_Addition(VRage.Library.Net.DefaultQoSProvider.Statistics.ReceivedTraffic@,VRage.Library.Net.DefaultQoSProvider.Statistics.ReceivedTraffic@)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.Statistics.ReceivedTraffic.op_Subtraction(VRage.Library.Net.DefaultQoSProvider.Statistics.ReceivedTraffic@,VRage.Library.Net.DefaultQoSProvider.Statistics.ReceivedTraffic@)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.Statistics.DroppedTraffic.op_Addition(VRage.Library.Net.DefaultQoSProvider.Statistics.DroppedTraffic@,VRage.Library.Net.DefaultQoSProvider.Statistics.DroppedTraffic@)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.Statistics.DroppedTraffic.op_Subtraction(VRage.Library.Net.DefaultQoSProvider.Statistics.DroppedTraffic@,VRage.Library.Net.DefaultQoSProvider.Statistics.DroppedTraffic@)">
            <inheritdoc />
        </member>
        <member name="T:VRage.Library.Net.DefaultQoSProvider.Statistics.Traffic">
            <summary>
            Sample of network traffic.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.Statistics.Traffic.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.Statistics.Traffic.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.Statistics.Traffic.ToString">
            <inheritdoc />
        </member>
        <member name="T:VRage.Library.Net.DefaultQoSProvider.Statistics.TrafficF">
            <summary>
            Sample of network traffic.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.Statistics.TrafficF.ToString">
            <inheritdoc />
        </member>
        <member name="P:VRage.Library.Net.DefaultQoSProvider.AbsoluteStatistics.Sent">
            <inheritdoc />
        </member>
        <member name="P:VRage.Library.Net.DefaultQoSProvider.AbsoluteStatistics.Received">
            <inheritdoc />
        </member>
        <member name="P:VRage.Library.Net.DefaultQoSProvider.AbsoluteStatistics.Dropped">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.AbsoluteStatistics.AddFrameSent(System.Int32,VRage.Library.Net.DefaultQoSProvider.FrameType,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.AbsoluteStatistics.AddFrameAcknowledged(System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.AbsoluteStatistics.AddFrameReceived(System.Int32,VRage.Library.Net.DefaultQoSProvider.FrameType)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.AbsoluteStatistics.DropFrame(System.Int32,System.Boolean,VRage.Library.Net.DefaultQoSProvider.Statistics.DroppedFrameType)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.WindowedStatistics.#ctor(System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="P:VRage.Library.Net.DefaultQoSProvider.WindowedStatistics.Sent">
            <inheritdoc />
        </member>
        <member name="P:VRage.Library.Net.DefaultQoSProvider.WindowedStatistics.Received">
            <inheritdoc />
        </member>
        <member name="P:VRage.Library.Net.DefaultQoSProvider.WindowedStatistics.Dropped">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.WindowedStatistics.AddFrameSent(System.Int32,VRage.Library.Net.DefaultQoSProvider.FrameType,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.WindowedStatistics.AddFrameAcknowledged(System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.WindowedStatistics.AddFrameReceived(System.Int32,VRage.Library.Net.DefaultQoSProvider.FrameType)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.WindowedStatistics.DropFrame(System.Int32,System.Boolean,VRage.Library.Net.DefaultQoSProvider.Statistics.DroppedFrameType)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.WindowedStatistics.Tick">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.WindowedStatistics.StatFrame.Add(VRage.Library.Net.DefaultQoSProvider.WindowedStatistics.StatFrame@,VRage.Library.Net.DefaultQoSProvider.WindowedStatistics.StatFrame@,VRage.Library.Net.DefaultQoSProvider.WindowedStatistics.StatFrame@)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.DefaultQoSProvider.WindowedStatistics.StatFrame.Subtract(VRage.Library.Net.DefaultQoSProvider.WindowedStatistics.StatFrame@,VRage.Library.Net.DefaultQoSProvider.WindowedStatistics.StatFrame@,VRage.Library.Net.DefaultQoSProvider.WindowedStatistics.StatFrame@)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.FrameIntegrityFilter.Dispose">
            <inheritdoc />
        </member>
        <member name="P:VRage.Library.Net.FrameIntegrityFilter.MinimumMTU">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.FrameIntegrityFilter.Send(System.Span{System.Byte})">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.FrameIntegrityFilter.PeekFrame(System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.FrameIntegrityFilter.TryGetFrame(System.Span{System.Byte}@)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.FrameIntegrityFilter.QueryMTU(System.Action{System.Int32})">
            <inheritdoc />
        </member>
        <member name="T:VRage.Library.Net.IQoSProvider">
            <summary>
            Interface representing an object that can implement message reliability over a unreliable connection.
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:VRage.Library.Net.IQoSProvider.MessagesAvailable">
            <summary>
            Whether there are messages available from the remote host.
            </summary>
        </member>
        <member name="P:VRage.Library.Net.IQoSProvider.HasPendingDeliveries">
            <summary>
            Whether this provider has outstanding messages that are awaiting delivery.
            </summary>
        </member>
        <member name="P:VRage.Library.Net.IQoSProvider.MaxNonBlockingMessageSize">
            <summary>
            Maximum size for a message that is guaranteed to be non-blocking if the message queue is not full.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.IQoSProvider.SendMessage(System.Span{System.Byte},System.Byte,VRage.Library.Net.SendMessageFlags)">
            <summary>
            Send a message to the remote host.
            </summary>
            <param name="message">The message to send.</param>
            <param name="channel">The channel to send the message through.</param>
            <param name="flags"></param>
            <returns>The result of the operation.</returns>
        </member>
        <member name="M:VRage.Library.Net.IQoSProvider.TryReceiveMessage(System.Span{System.Byte}@,System.Byte@)">
            <summary>
            Attempt to receive a message from the remote host.
            </summary>
            <remarks>This call may block.</remarks>
            <param name="message">The message data</param>
            <param name="channel">The message channel.</param>
            <returns><code>true</code> if a valid message could be read. Otherwise <code>false</code></returns>
        </member>
        <member name="M:VRage.Library.Net.IQoSProvider.TryPeekMessage(System.Int32@,System.Byte@)">
            <summary>
            Peek the channel and size of the next available message.
            </summary>
            <remarks>This call may block.</remarks>
            <param name="size">The message size.</param>
            <param name="channel">The message channel.</param>
            <returns>Whether there was a message to peek.</returns>
        </member>
        <member name="M:VRage.Library.Net.IQoSProvider.ProcessWriteQueues">
            <summary>
            Process all pending write queues.
            </summary>
            <remarks>
            For implementations that buffer messages this will require them to be flushed immediately.
            </remarks>
        </member>
        <member name="M:VRage.Library.Net.IQoSProvider.ProcessReadQueues">
            <summary>
            Pool for received frames.
            </summary>
        </member>
        <member name="T:VRage.Library.Net.IUnreliableTransportChannel">
            <summary>
            Represents a unreliable message-based connection between two peers.
            </summary>
        </member>
        <member name="P:VRage.Library.Net.IUnreliableTransportChannel.MinimumMTU">
            <summary>
            Guaranteed minimum value for MTU over this transport. It should always be possible to send packets of this size between hosts.
            </summary>
            <remarks>This value should be constant over the lifetime of the connection.</remarks>
        </member>
        <member name="M:VRage.Library.Net.IUnreliableTransportChannel.Send(System.Span{System.Byte})">
            <summary>
            Send a frame of data to the remote host.
            </summary>
            <param name="frame"></param>
            <returns>Number of bytes actually transmitted.</returns>
        </member>
        <member name="M:VRage.Library.Net.IUnreliableTransportChannel.PeekFrame(System.Int32@)">
            <summary>
            Whether there are any un-processed frames from the remote host.
            </summary>
            <param name="frameSize"></param>
            <remarks>This query should be non-blocking.</remarks>
        </member>
        <member name="M:VRage.Library.Net.IUnreliableTransportChannel.TryGetFrame(System.Span{System.Byte}@)">
            <summary>
            Attempt to read a frame from the remote end.
            </summary>
            <param name="frame">The memory range where the frame is to be stored. The length of the span will be adjusted to match the actual size of the received frame.</param>
            <returns>Whether a valid frame was actually read.</returns>
            <remarks>If the frame is larger than the provided buffer any additional data will be lost.</remarks>
        </member>
        <member name="M:VRage.Library.Net.IUnreliableTransportChannel.QueryMTU(System.Action{System.Int32})">
            <summary>
            Query the actual Minimum Transmission Unit for the connection. This value can be greater than <see cref="P:VRage.Library.Net.IUnreliableTransportChannel.MinimumMTU"/>.
            </summary>
            <remarks>This method should be non-blocking.</remarks>
            <param name="result">Callback invoked when the result is available.</param>
        </member>
        <member name="T:VRage.Library.Net.MessageTransferResult">
            <summary>
            Possible result codes when transferring a message.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.MessageTransferResult.QueuedSuccessfully">
            <summary>
            Message was added to queue.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.MessageTransferResult.QueueFull">
            <summary>
            The message queue is full.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.MessageTransferResult.OversizedMessage">
            <summary>
            The message is oversized.
            </summary>
        </member>
        <member name="T:VRage.Library.Net.PassThroughQoSProvider">
            <summary>
            Placeholder implementation <see cref="T:VRage.Library.Net.IQoSProvider"/> interface without actually providing any quality of service.
            </summary>
            <remarks>This class is only useful for testing.</remarks>
        </member>
        <member name="P:VRage.Library.Net.PassThroughQoSProvider.MessagesAvailable">
            <inheritdoc />
        </member>
        <member name="P:VRage.Library.Net.PassThroughQoSProvider.HasPendingDeliveries">
            <inheritdoc />
        </member>
        <member name="P:VRage.Library.Net.PassThroughQoSProvider.MaxNonBlockingMessageSize">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.PassThroughQoSProvider.SendMessage(System.Span{System.Byte},System.Byte,VRage.Library.Net.SendMessageFlags)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.PassThroughQoSProvider.TryReceiveMessage(System.Span{System.Byte}@,System.Byte@)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.PassThroughQoSProvider.TryPeekMessage(System.Int32@,System.Byte@)">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.PassThroughQoSProvider.ProcessWriteQueues">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.PassThroughQoSProvider.ProcessReadQueues">
            <inheritdoc />
        </member>
        <member name="M:VRage.Library.Net.PassThroughQoSProvider.Dispose">
            <inheritdoc />
        </member>
        <member name="T:VRage.Library.Net.QoSProviderExtensions">
            <summary>
            Extension methods for the QoS provider.
            </summary>
        </member>
        <member name="M:VRage.Library.Net.QoSProviderExtensions.ProcessQueues(VRage.Library.Net.IQoSProvider)">
            <summary>
            Process all queues in the provider.
            </summary>
            <param name="provider"></param>
        </member>
        <member name="T:VRage.Library.Net.SendMessageFlags">
            <summary>
            Flags altering how message sending should be performed..
            </summary>
        </member>
        <member name="F:VRage.Library.Net.SendMessageFlags.HighPriority">
            <summary>
            Causes the message queue to be flushed immediately upon sending the message.
            </summary>
        </member>
        <member name="F:VRage.Library.Net.SendMessageFlags.NonBlocking">
            <summary>
            Causes the send operation to fail if it could block the caller.
            </summary>
        </member>
        <member name="T:VRage.Library.Parallelization.DataGuard">
            <summary>
            This utility construct reports incorrect data access/synchronization
            Correct access is only asserted, not ensured in any way. No locking or spinning is performed in order to achieve any kind syncing!
            </summary>
        </member>
        <member name="T:VRage.Library.Threading.ProcessUtil">
            <summary>
            Collection of utilities for advanced process and thread management.
            </summary>
        </member>
        <member name="M:VRage.Library.Threading.ProcessUtil.SetThreadProcessorAffinity(System.Int32[])">
            <summary>
            Sets the processor affinity of the current thread.
            </summary>
            <param name="cpus">A list of CPU numbers. The values should be
            between 0 and <see cref="P:System.Environment.ProcessorCount"/>.</param>
        </member>
        <member name="T:VRage.Library.Threading.SpinLock">
            <summary>
            A struct which implements a spin lock.
            </summary>
        </member>
        <member name="M:VRage.Library.Threading.SpinLock.Enter">
            <summary>
            Enters the lock. The calling thread will spin wait until it gains ownership of the lock.
            </summary>
        </member>
        <member name="M:VRage.Library.Threading.SpinLock.TryEnter">
            <summary>
            Tries to enter the lock.
            </summary>
            <returns><c>true</c> if the lock was successfully taken; else <c>false</c>.</returns>
        </member>
        <member name="M:VRage.Library.Threading.SpinLock.Exit">
            <summary>
            Exits the lock. This allows other threads to take ownership of the lock.
            </summary>
        </member>
        <member name="T:VRage.Library.Utils.IMyCondition">
            <summary>
            Interface of totally generic condition.
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.IMyCondition.Evaluate">
            <summary>
            Evaluate the condition, it can be true/false.
            </summary>
        </member>
        <member name="F:VRage.Library.Utils.MyEnum`1.m_names">
            <summary>
            Cached strings to avoid ToString() calls. These values are not readable in obfuscated builds!
            </summary>
        </member>
        <member name="T:VRage.Library.Utils.MyGameTimer">
            <summary>
            Global thread-safe timer.
            Time for update and time for draw must be copied at the beginning of update and draw.
            </summary>
        </member>
        <member name="F:VRage.Library.Utils.MyGameTimer.Frequency">
            <summary>
            Number of ticks per seconds
            </summary>
        </member>
        <member name="P:VRage.Library.Utils.MyGameTimer.ElapsedTimeSpan">
            <summary>
            This may not be accurate for large values - double accuracy
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyHashRandomUtils.CreateFloatFromMantissa(System.UInt32)">
            <summary>
            Create a [0, 1) float from it's mantissa.
            </summary>
            <param name="m">Mantissa bits.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.Library.Utils.MyHashRandomUtils.UniformFloatFromSeed(System.Int32)">
            <summary>
            Compute a float in the range [0, 1) created from the the seed.
            
            For uniformly distributed seeds this method will produce uniformly distributed values.
            </summary>
            <param name="seed">Any integer to be used as a seed. The seed needs not be super uniform since it will be hashed.</param>
            <returns>A float in the range [0, 1)</returns>
        </member>
        <member name="M:VRage.Library.Utils.MyImageHeaderUtils.Read_DDS_HeaderData(System.String,VRage.Library.Utils.MyImageHeaderUtils.DDS_HEADER@)">
            <summary>
            Reads the header of standard DDS texture without reading the rest of its contents.
            Checks for magic constant.
            </summary>
            <param name="filePath">Path to dds.</param>
            <param name="header">Output header</param>
            <returns>Success flag.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:VRage.Library.Utils.MyImageHeaderUtils.Read_PNG_Dimensions(System.String,System.Int32@,System.Int32@)" -->
        <member name="M:VRage.Library.Utils.MyInterpolationQueue`1.DiscardOld(VRage.Library.Utils.MyTimeSpan)">
            <summary>
            Discards old samples, keeps at least 2 samples to be able to interpolate or extrapolate.
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyInterpolationQueue`1.AddSample(`0@,VRage.Library.Utils.MyTimeSpan)">
            <summary>
            Adds sample with timestamp, it must be larger than last timestamp!
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyInterpolationQueue`1.Interpolate(VRage.Library.Utils.MyTimeSpan,`0@)">
            <summary>
            Discards old frame (keeps one older) and interpolates between two samples using interpolator.
            Returns interpolator
            There must be at least one sample!
            </summary>
        </member>
        <member name="T:VRage.Library.Utils.MyIterableComplementSet`1">
            Over a given set of elements W this class maintains two subsets A and B such that
            A  B = , A  B = W, with constant time operations for moving elements from one set to the other.
            
            Both subsets are individually iterable, as well as the whole W.
            
            The order of elements in either set is never preserved.
            
            When using this class with value types beware that they will be duplicated internally.
            Prefer to use class types or some form of lightweight reference with this.
        </member>
        <member name="M:VRage.Library.Utils.MyLibraryUtils.NormalizeFloat(System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Normalizes uniform-spaced float within min/max into uint with specified number of bits.
            This does not preserve 0 when min = -max
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyLibraryUtils.DenormalizeFloat(System.UInt32,System.Single,System.Single,System.Int32)">
            <summary>
            Denormalizes uint with specified number of bits into uniform-space float within min/max.
            This does not preserve 0 when min = -max
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyLibraryUtils.NormalizeFloatCenter(System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Normalizes uniform-spaced float within min/max into uint with specified number of bits.
            This preserves 0 when min = -max
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyLibraryUtils.DenormalizeFloatCenter(System.UInt32,System.Single,System.Single,System.Int32)">
            <summary>
            Denormalizes uint with specified number of bits into uniform-space float within min/max.
            This preserves 0 when min = -max
            </summary>
        </member>
        <member name="T:VRage.Library.Utils.MyRandom">
            <summary>
            Original C# implementation which allows settings the seed.
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyRandom.SetSeed(System.Int32)">
            <summary>
            Sets new seed, only use this method when you have separate instance of MyRandom.
            Setting seed for RNG used for EntityId without reverting to previous state is dangerous.
            Use PushSeed for EntityId random generator.
            </summary>
        </member>
        <member name="M:VRage.Library.Utils.MyRandom.NextFloat">
            Returns random number between 0 and 1.
        </member>
        <member name="M:VRage.Library.Utils.MyRandom.NextDouble">
            Returns random number between 0 and 1.
        </member>
        <member name="T:VRage.Library.Utils.MyTimeSpan">
            <summary>
            Hi-resolution time span. Beware: the resolution can be different on different systems!
            </summary>
        </member>
        <member name="P:VRage.Library.Utils.MyTimeSpan.TimeSpan">
            <summary>
            This may not be accurate for large values - double accuracy
            </summary>
        </member>
        <member name="T:VRage.Collections.CachingDictionary`2">
            <summary>
            Dictionary wrapper that allows for addition and removal even during enumeration.
            Done by caching changes and allowing explicit application using Apply* methods.
            </summary>
        </member>
        <member name="T:VRage.Collections.CachingList`1">
            <summary>
            List wrapper that allows for addition and removal even during enumeration.
            Done by caching changes and allowing explicit application using Apply* methods.
            </summary>
        </member>
        <member name="M:VRage.Collections.CachingList`1.RemoveAtImmediately(System.Int32)">
            <summary>
            Immediately removes an element at the specified index.
            </summary>
            <param name="index">Index of the element to remove immediately.</param>
        </member>
        <member name="M:VRage.Collections.CachingList`1.CopyWithChanges">
            <summary>
            Create a copy of the internal list with changes applied.
            </summary>
            <remarks>This method does not modify the collection</remarks>
            <returns>A copy of the list with all changes applied.</returns>
        </member>
        <member name="T:VRage.Collections.ConcurrentCachingList`1">
            <summary>
            List wrapper that allows for addition and removal even during enumeration.
            Done by caching changes and allowing explicit application using Apply* methods.
            
            This version has individual locks for cached and non-cached versions, allowing
            each to be managed efficiently even across multiple threads
            </summary>
        </member>
        <member name="M:VRage.Collections.ConcurrentCachingList`1.RemoveAtImmediately(System.Int32)">
            <summary>
            Immediately removes an element at the specified index.
            </summary>
            <param name="index">Index of the element to remove immediately.</param>
        </member>
        <member name="T:VRage.Collections.MyConcurrentBucketPool`1">
            <summary>
            Simple thread-safe pool.
            Can store external objects by calling return.
            Creates new instances when empty.
            </summary>
        </member>
        <member name="M:VRage.Collections.MyConcurrentBufferPool`1.GetNearestBiggerPowerOfTwo(System.Int32)">
             <summary>
            Copy of VRageMath.MathHelper#GetNearestBiggerPowerOfTwo
             </summary>
        </member>
        <member name="T:VRage.Collections.MyConcurrentDictionary`2">
            <summary>
            Simple thread-safe queue.
            Uses spin-lock
            </summary>
        </member>
        <member name="T:VRage.Collections.MyConcurrentHashSet`1">
            <summary>
            Simple thread-safe queue.
            Uses spin-lock
            </summary>
        </member>
        <member name="P:VRage.Collections.MyConcurrentList`1.ListUnsafe">
            <summary>
            Debug only!! Thread unsafe
            </summary>
        </member>
        <member name="P:VRage.Collections.MyConcurrentList`1.List">
            <summary>
            Manage lock yourself when accesing the list!
            </summary>
        </member>
        <member name="M:VRage.Collections.MyConcurrentList`1.Add(`0)">
            <summary>
            Does NOT call sort
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:VRage.Collections.MyConcurrentList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add a range of items to this list.
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:VRage.Collections.MyConcurrentPool`1">
            <summary>
            Simple thread-safe pool.
            Can store external objects by calling return.
            Creates new instances when empty.
            </summary>
        </member>
        <member name="T:VRage.Collections.MyConcurrentQueue`1">
            <summary>
            Simple thread-safe queue.
            Uses spin-lock
            </summary>
        </member>
        <member name="T:VRage.Collections.MyConcurrentSortedDictionary`2">
            <summary>
            Simple thread-safe queue.
            Uses spin-lock
            </summary>
        </member>
        <member name="T:VRage.Collections.MyCommitQueue`1">
            <summary>
            Basic copy-on-commit implementation, later it will be faster by using one queue with 2 tails
            </summary>
        </member>
        <member name="T:VRage.Collections.MyDistributedUpdater`2">
            <summary>
            Class distributing updates on large amount of objects in configurable intervals. 
            </summary>
        </member>
        <member name="M:VRage.Collections.MyDistributedUpdater`2.System#Collections#Generic#IEnumerable{TElement}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:VRage.Collections.MyDistributedUpdater`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:VRage.Collections.MyDistributedUpdater`2.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:VRage.Collections.MyDistributedUpdater`2.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="P:VRage.Collections.MyDistributedUpdater`2.Enumerator.Current">
            <inheritdoc />
        </member>
        <member name="P:VRage.Collections.MyDistributedUpdater`2.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="M:VRage.Collections.MyDistributedUpdater`2.Enumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="T:VRage.Collections.MyIntervalList">
            <summary>
            <para>A set of integer numbers optimized for sets with long consecutive runs. Each interval is stored as two values in m_list: the lower and the upper bound.</para>
            <para>For example, the set of numbers 2, 3, 4, 5, 7, 9, 10, 11, 12, 13 (or alternatively in the interval notation &lt;2, 5&gt; U &lt;7, 7&gt; U &lt;9, 13&gt;)
            is saved as a list { 2, 5, 7, 7, 9, 13 }</para>
            </summary>
        </member>
        <member name="M:VRage.Collections.MyIntervalList.Add(System.Int32)">
            <summary>
            Add a value to the list
            </summary>
        </member>
        <member name="T:VRage.Collections.MyQueue`1">
            <summary>
            Allows access to queue by index
            Otherwise implementation is similar to regular queue
            </summary>
        </member>
        <member name="M:VRage.Collections.MySinglyLinkedList`1.Split(VRage.Collections.MySinglyLinkedList{`0}.Enumerator,System.Int32)">
            <summary>
            Splits the list into two.
            This list's end will be the node pointed by newLastPosition and the newly created list will begin with the next node.
            </summary>
            <param name="newLastPosition">Enumerator that points to the new last position in the list.</param>
            <param name="newCount">New number of elements in this list. If set to -1, it is calculated automatically,
            but that would make the split an O(N) operation. Beware: If you set this parameter, be sure to always set the
            correct number, otherwise, you'd cause both lists (this one and the returned one) to return a wrong number of
            elements in the future.</param>
            <returns>The newly created list</returns>
        </member>
        <member name="T:VRage.Collections.MySwapQueue`1">
            <summary>
            Holds three objects in safe manner, use when Reader requires only last valid data.
            One object is used for reading, one for writing and third is used as buffer, so reader/writer don't have to wait on the other.
            </summary>
        </member>
        <member name="M:VRage.Collections.MySwapQueue`1.RefreshRead">
            <summary>
            Updates data for reading if there's something new
            Returns true when Read was updated, returns false when Read was not changed
            </summary>
        </member>
        <member name="M:VRage.Collections.MySwapQueue`1.CommitWrite">
            <summary>
            Commits Write and replaces write with new object ready for new writing
            </summary>
        </member>
        <member name="P:VRage.Collections.MyUniqueList`1.Count">
            <summary>
            O(1)
            </summary>
        </member>
        <member name="P:VRage.Collections.MyUniqueList`1.Item(System.Int32)">
            <summary>
            O(1)
            </summary>
        </member>
        <member name="M:VRage.Collections.MyUniqueList`1.Add(`0)">
            <summary>
            O(1)
            </summary>
        </member>
        <member name="M:VRage.Collections.MyUniqueList`1.Insert(System.Int32,`0)">
            <summary>
            O(n)
            </summary>
        </member>
        <member name="M:VRage.Collections.MyUniqueList`1.Remove(`0)">
            <summary>
            O(n)
            </summary>
        </member>
        <member name="M:VRage.Collections.MyUniqueList`1.Contains(`0)">
            <summary>
            O(1)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:VRage.Collections.ObservableCollection`1" -->
        <member name="T:VRage.Collections.ObservableCollection`1.Enumerator">
            <summary>
            Enumerator which uses index access.
            Index access on Collection is O(1) operation
            </summary>
        </member>
        <member name="M:VRage.Collections.ObservableCollection`1.ClearItems">
            <summary>
            Clears the items.
            </summary>
        </member>
        <member name="M:VRage.Collections.ObservableCollection`1.GetEnumerator">
            <summary>
            Gets allocation free enumerator (returns struct)
            </summary>
        </member>
        <member name="T:VRage.InstanceComparer`1">
            <summary>
            Most probably fastest possible comparer which compares instances of objects
            </summary>
        </member>
        <member name="M:VRage.Generics.MyConcurrentObjectsPool`1.AllocateOrCreate(`0@)">
            <summary>
            Returns true when new item was allocated
            </summary>
        </member>
        <member name="P:VRage.Serialization.SerializableDictionaryHack`2.Dictionary">
            <summary>
            Public stuff dictionary.
            </summary>
            <remarks>
            Note the XmlIgnore attribute.
            </remarks>
        </member>
        <member name="P:VRage.Serialization.SerializableDictionaryHack`2.DictionaryEntryProp">
            <summary>
            Property created expressly for the XmlSerializer
            </summary>
            <remarks>
            Note the XML Serialiazation attributes; they control what elements are named when this object is serialized.
            </remarks>
        </member>
        <member name="T:VRage.Serialization.BlitCollectionSerializer`2">
            <summary>
            This is not optimal in terms of allocations, but works fine
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyObjectFlags.None">
            <summary>
            No serialization flags
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyObjectFlags.DefaultZero">
            <summary>
            Do not serialize member when it has default value, null for objects, zeros for structs.
            In binary streams, bit is written to indicate whether object had a value or not.
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyObjectFlags.Nullable">
            <summary>
            Alias to default value.
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyObjectFlags.Dynamic">
            <summary>
            Member can store subclasses of specified type, actual member type will be serialized as well.
            Valid only on class members (not for value types).
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyObjectFlags.DefaultValueOrEmpty">
            <summary>
            Applies only to collections.
            When serializing empty collection (zero element count) it will behave like DefaultValue.
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyObjectFlags.DynamicDefault">
            <summary>
            Same as dynamic, but stores a bit indicating whether serialized type is different from member type or not.
            When it's same, type is not serialized. Usefull when some instances have default type.
            </summary>
        </member>
        <member name="T:VRage.Serialization.MyPrimitiveFlags">
            <summary>
            Primitive flags are passed down the object hierarchy.
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.None">
            <summary>
            No primitive flags.
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.Signed">
            <summary>
            Flag which indicates whether primitive is signed.
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.Normalized">
            <summary>
            Flag which indicates whether primitive is normalized.
            Exact behavior depends on actual type (0..1, -1..1, normalized vector, etc)
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.Variant">
            <summary>
            Serialize member as unsigned variant (variable length integer, 0-127...1-byte, 127-32767...2-byte, etc)
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.VariantSigned">
            <summary>
            Serialize member as unsigned signed (-63..64, 1-byte etc, -32767..32768, 2-byte, etc)
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.Ascii">
            <summary>
            Serialize string in ascii encoding
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.Utf8">
            <summary>
            Serialize string in UTF8 encoding
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.FixedPoint8">
            <summary>
            Fixed point 8-bit precision, use with normalized
            </summary>
        </member>
        <member name="F:VRage.Serialization.MyPrimitiveFlags.FixedPoint16">
            <summary>
            Fixed point 16-bit precision, use with normalized
            </summary>
        </member>
        <member name="P:VRage.Serialization.SerializableDictionary`2.Dictionary">
            <summary>
            Public stuff dictionary.
            </summary>
            <remarks>
            Note the XmlIgnore attribute.
            </remarks>
        </member>
        <member name="P:VRage.Serialization.SerializableDictionary`2.DictionaryEntryProp">
            <summary>
            Property created expressly for the XmlSerializer
            </summary>
            <remarks>
            Note the XML Serialiazation attributes; they control what elements are named when this object is serialized.
            </remarks>
        </member>
        <member name="F:VRage.Serialization.SerializeAttribute.Flags">
            <summary>
            Serialization flags for member itself.
            </summary>
        </member>
        <member name="F:VRage.Serialization.SerializeAttribute.PrimitiveFlags">
            <summary>
            Serialization flags for primitive types, when defined for types, passed down the hierarchy.
            </summary>
        </member>
        <member name="F:VRage.Serialization.SerializeAttribute.FixedLength">
            <summary>
            Length for fixed length arrays, collections and strings.
            </summary>
        </member>
        <member name="F:VRage.Serialization.SerializeAttribute.DynamicSerializerType">
            <summary>
            Type of dynamic resolver.
            </summary>
        </member>
        <member name="F:VRage.Serialization.SerializeAttribute.Kind">
            <summary>
            Kind of attribute, specify Item for collections like list, array or dictionary value, specify Key for dictionary key.
            </summary>
        </member>
        <member name="T:VRage.Serialization.TupleSerializer">
            <summary>
            Serializer for empty class, does nothing
            </summary>
        </member>
        <member name="T:VRage.Compiler.IlReader">
            <summary>
            Reads method body and returns instructions
            </summary>
        </member>
        <member name="T:VRage.Compiler.TypeNameHelper`1">
            <summary>
            Type name which does not make allocations
            </summary>
        </member>
        <member name="T:VRage.Compression.MyZipArchive">
            <summary>
            Class based on http://www.codeproject.com/Articles/209731/Csharp-use-Zip-archives-without-external-libraries.
            </summary>
        </member>
        <member name="T:VRage.Compression.MyStreamWrapper">
            <summary>
            Stream wrapper which will close both stream and other IDisposable object
            </summary>
        </member>
        <member name="M:VRage.Common.Utils.MyRSA.GenerateKeys(System.Byte[]@,System.Byte[]@)">
            <summary>
            Generate keys into specified files.
            </summary>
            <param name="publicKeyFileName">Name of the file that will contain public key</param>
            <param name="privateKeyFileName">Name of the file that will contain private key</param>
        </member>
        <member name="M:VRage.Common.Utils.MyRSA.SignData(System.String,System.String)">
            <summary>
            Signs given data with provided key.
            </summary>
            <param name="data">data to sign (in base64 form)</param>
            <param name="privateKey">private key (in base64 form)</param>
            <returns>Signed data (string in base64 form)</returns>
        </member>
        <member name="M:VRage.Common.Utils.MyRSA.SignHash(System.Byte[],System.Byte[])">
            <summary>
            Signs given hash with provided key.
            </summary>
            <param name="hash">hash to sign</param>
            <param name="privateKey">private key</param>
            <returns>Signed hash (string in base64 form)</returns>
        </member>
        <member name="M:VRage.Common.Utils.MyRSA.SignHash(System.String,System.String)">
            <summary>
            Signs given hash with provided key.
            </summary>
            <param name="hash">hash to sign (in base64 form)</param>
            <param name="privateKey">private key (in base64 form)</param>
            <returns>Signed hash (string in base64 form)</returns>
        </member>
        <member name="M:VRage.Common.Utils.MyRSA.VerifyHash(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Verifies that a digital signature is valid by determining the hash value
            in the signature using the provided public key and comparing it to the provided hash value.
            </summary>
            <param name="hash">hash to test</param>
            <param name="signedHash">already signed hash</param>
            <param name="publicKey">signature</param>
            <returns>true if the signature is valid; otherwise, false.</returns>
        </member>
        <member name="M:VRage.Common.Utils.MyRSA.VerifyHash(System.String,System.String,System.String)">
            <summary>
            Verifies that a digital signature is valid by determining the hash value
            in the signature using the provided public key and comparing it to the provided hash value.
            </summary>
            <param name="hash">hash to test</param>
            <param name="signedHash">already signed hash (in base64 form)</param>
            <param name="publicKey">signature (in base64 form)</param>
            <returns>true if the signature is valid; otherwise, false.</returns>
        </member>
        <member name="M:VRage.Common.Utils.MyRSA.VerifyData(System.String,System.String,System.String)">
            <summary>
            Verifies that a digital signature is valid by determining the hash value
            in the signature using the provided public key and comparing it to the hash value of the provided data.
            </summary>
            <param name="originalMessage">original data</param>
            <param name="signedMessage">signed message (in base64 form)</param>
            <param name="publicKey">signature (in base64 form)</param>
            <returns>true if the signature is valid; otherwise, false.</returns>
        </member>
        <member name="T:VRage.Common.Utils.MyChecksums">
            <summary>
            Helper class for serializing and deserializing checksum file.
            </summary>
        </member>
        <member name="M:VRage.Cryptography.MySHA256.Create">
            <summary>
            Creates FIPS compliant crypto provider if available, otherwise pure managed implementation.
            </summary>
        </member>
        <member name="T:VRage.Exceptions">
            <summary>
            Provides a set of methods that help throwing exceptions. This class cannot be inherited.
            </summary>
        </member>
        <member name="M:VRage.Exceptions.ThrowIf``1(System.Boolean)">
            <summary>
            Specifies a condition and throws an exception with the provided message if the condition is true.
            </summary>
            <typeparam name="TException">The exception to throw if the condition is true.</typeparam>
            <param name="condition">The conditional expression to test.</param>
        </member>
        <member name="M:VRage.Exceptions.ThrowIf``1(System.Boolean,System.String)">
            <summary>
            Specifies a condition and throws an exception with the provided message if the condition is true.
            </summary>
            <typeparam name="TException">The exception to throw if the condition is true.</typeparam>
            <param name="condition">The conditional expression to test.</param>
            <param name="arg1">The arg1.</param>
        </member>
        <member name="M:VRage.Exceptions.ThrowIf``1(System.Boolean,System.String,System.String)">
            <summary>
            Specifies a condition and throws an exception with the provided message if the condition is true.
            </summary>
            <typeparam name="TException">The exception to throw if the condition is true.</typeparam>
            <param name="condition">The conditional expression to test.</param>
            <param name="arg1">The arg1.</param>
            <param name="arg2">The arg2.</param>
        </member>
        <member name="M:VRage.Exceptions.ThrowIf``1(System.Boolean,System.Object[])">
            <summary>
            Specifies a condition and throws an exception with the provided message if the condition is true.
            </summary>
            <typeparam name="TException">The exception to throw if the condition is true.</typeparam>
            <param name="condition">The conditional expression to test.</param>
            <param name="args">Exception arguments.</param>
        </member>
        <member name="M:VRage.Exceptions.ThrowAny``1(System.Boolean[],System.Object[])">
            <summary>
            Specifies a conditions and throws an exception with the provided message if any of the conditions is true.
            </summary>
            <typeparam name="TException">The exception to throw if the condition is true.</typeparam>
            <param name="conditions">The conditional expression to test.</param>
            <param name="args">Exception arguments.</param>
        </member>
        <member name="M:VRage.Exceptions.ThrowAll``1(System.Boolean[],System.Object[])">
            <summary>
            Specifies a conditions and throws an exception with the provided message if all conditions are true.
            </summary>
            <typeparam name="TException">The exception to throw if the condition is true.</typeparam>
            <param name="conditions">The conditional expression to test.</param>
            <param name="args">Exception arguments.</param>
        </member>
        <member name="M:VRage.Extensions.ArrayOfTypeEnumerator`3.GetEnumerator">
            <summary>
            So we can put this into foreach
            </summary>
        </member>
        <member name="M:VRage.DateTimeExtensions.ToDateTimeFromUnixTimestamp(System.UInt32)">
            <summary>
            Converts seconds passed since unix epoch into DateTime.
            </summary>
            <param name="timestamp"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.DateTimeExtensions.ToUnixTimestamp(System.DateTime)">
            <summary>
            Converts DateTime to seconds passed since 1/1/1970.
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.MemberHelper.GetMember``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Gets the memberinfo of field/property on static class.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="selector">The selector.</param>
            <returns></returns>
        </member>
        <member name="M:VRage.MemberHelper`1.GetMember``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
             Gets the memberinfo of field/property on instance class.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="selector">The selector.</param>
            <returns></returns>
        </member>
        <member name="F:VRage.TypeExtensions.CoreTypes">
            <summary>
            CLR core types that you should account for.
            </summary>
        </member>
        <member name="M:VRage.TypeExtensions.IsAccessible(System.Type)">
            <summary>
            Check that the type is public to an unrelated scope, this will also check the declaring type hierarchy if needed..
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.TypeExtensions.PrettyName(System.Type)">
            <summary>
            Get full type name with full namespace names
            </summary>
            <param name="type">Type. May be generic or nullable</param>
            <returns>Full type name, fully qualified namespaces</returns>
        </member>
        <member name="M:VRage.FileSystem.IFileProvider.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Opens file, returns null when file does not exists
            </summary>
        </member>
        <member name="M:VRage.FileSystem.IFileProvider.DirectoryExists(System.String)">
            <summary>
            True if directory exists
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.FileSystem.IFileProvider.GetFiles(System.String,System.String,VRage.FileSystem.MySearchOption)">
            <summary>
            Returns list of files in directory
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.FileSystem.IFileProvider.FileExists(System.String)">
            <summary>
            True if file exists
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="F:VRage.FileSystem.MyContentPath.Path">
            <summary>
            Relative path within the Mod/Content structure.
            Do not set directly. Public only for Object buidler purposes.
            </summary>
        </member>
        <member name="F:VRage.FileSystem.MyContentPath.ModFolder">
            <summary>
            Name of the Mod.
            Do not set directly. Public only for Object buidler purposes.
            </summary>
        </member>
        <member name="P:VRage.FileSystem.MyContentPath.Absolute">
            <summary>
            Returns respective absolute path.
            </summary>
        </member>
        <member name="P:VRage.FileSystem.MyContentPath.RootFolder">
            <summary>
            Returns respective absolute path to root (Content/ModsFolder).
            </summary>
        </member>
        <member name="P:VRage.FileSystem.MyContentPath.AlternatePath">
            <summary>
            Possible Content alternative of modded files.
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyContentPath.GetExitingFilePath">
            <summary>
            Helper method.
            </summary>
            <returns>Valid file path to existing file.</returns>
        </member>
        <member name="M:VRage.FileSystem.MyContentPath.SetPath(System.String,System.String)">
            <summary>
            Use this method to get the ModFolder automaticaly adjusted.
            </summary>
            <param name="path">Absolute or relative path within the content structure (Content/Mods).</param>
        </member>
        <member name="M:VRage.FileSystem.MyContentPath.op_Implicit(System.String)~VRage.FileSystem.MyContentPath">
            <summary>
            Assignment operator.
            </summary>
            <param name="path">Absolute path to content</param>
            <returns></returns>
        </member>
        <member name="M:VRage.FileSystem.MyFileProviderAggregator.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Opens file, returns null when file does not exists or cannot be opened
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.ReplaceFileProvider``1(VRage.FileSystem.IFileProvider)">
            <summary>
            Replace one of the built-in file providers for MyFileSystem.
            </summary>
            <typeparam name="TReplaced"></typeparam>
            <param name="instance"></param>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.OpenRead(System.String)">
            <summary>
            Opens file for reading
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.OpenRead(System.String,System.String)">
            <summary>
            Opens file for reading, convenient method with two paths to combine
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.OpenWrite(System.String,System.IO.FileMode)">
            <summary>
            Creates or overwrites existing file
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.OpenWrite(System.String,System.String,System.IO.FileMode)">
            <summary>
            Creates or overwrites existing file, convenient method with two paths to combine
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.CheckFileWriteAccess(System.String)">
            <summary>
            Checks write access for file
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.MakeRelativePath(System.String,System.String)">
            <summary>
            Creates a relative path from one file or folder to another.
            </summary>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.UnTerminatePath(System.String)">
            <summary>
            Return the trailing directory separator of the provided path if any.
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.CopyAll(System.String,System.String)">
            <summary>
            Copy all files and folders from a source directory to the target directory.
            </summary>
            <param name="source">the source path</param>
            <param name="target">the target path</param>        
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.CopyAll(System.String,System.String,System.Predicate{System.String})">
            <summary>
            Copy all files and folders from a source directory to the target directory, excluding any paths that do not match the provided condition predicate.
            </summary>
            <param name="source">the source path</param>
            <param name="target">the target path</param>        
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.EnsureDirectoryExists(System.String)">
            <summary>
            Ensure that the directory identified by the specified path does exist.
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:VRage.FileSystem.MyFileSystem.IsDirectory(System.String)">
            <summary>
            Checks if the path is directory
            </summary>
            <param name="path">the path</param>
            <returns></returns>
        </member>
        <member name="M:VRage.FileSystem.MyZipFileProvider.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            FileShare is ignored
            Usage: C:\Users\Data\Archive.zip\InnerFolder\file.txt
            </summary>
        </member>
        <member name="M:VRage.Groups.IGroupData`1.OnCreate``1(VRage.Groups.MyGroups{`0,``0}.Group)">
            <summary>
            Group is taken from pool
            </summary>
        </member>
        <member name="M:VRage.Groups.IGroupData`1.OnRelease">
            <summary>
            Group is returned to pool
            </summary>
        </member>
        <member name="M:VRage.Groups.IGroupData`1.OnNodeAdded(`0)">
            <summary>
            Node is added to group
            </summary>
        </member>
        <member name="M:VRage.Groups.IGroupData`1.OnNodeRemoved(`0)">
            <summary>
            Node is removed from group
            </summary>
        </member>
        <member name="T:VRage.Groups.MyGroups`2.MajorGroupComparer">
            <summary>
            Return true when "major" is really major group, otherwise false.
            </summary>
        </member>
        <member name="P:VRage.Groups.MyGroups`2.SupportsOphrans">
            <summary>
            When true, groups with one member are supported.
            You can use AddNode and RemoveNode.
            You have to manually call RemoveNode!
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroups`2.#ctor(System.Boolean,VRage.Groups.MyGroups{`0,`1}.MajorGroupComparer)">
            <summary>
            Initializes a new instance of MyGroups class.
            </summary>
            <param name="supportOphrans">When true, groups with one member are supported and you have to manually call RemoveNode!</param>
            <param name="groupSelector">Major group selector, when merging two groups, major group is preserved. By default it's larger group.</param>
        </member>
        <member name="M:VRage.Groups.MyGroups`2.AddNode(`0)">
            <summary>
            Adds node, asserts when node already exists
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroups`2.RemoveNode(`0)">
            <summary>
            Removes node, asserts when node is not here or node has some existing links
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroups`2.CreateLink(System.Int64,`0,`0)">
            <summary>
            Creates link between parent and child.
            Parent is owner of constraint.
            LinkId must be unique for parent and for child; LinkId is unique node-node identifier.
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroups`2.BreakLink(System.Int64,`0,`0)">
            <summary>
            Breaks link between parent and child, you can set child to null to find it by linkId.
            Returns true when link was removed, returns false when link was not found.
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroups`2.TryReleaseNode(VRage.Groups.MyGroups{`0,`1}.Node)">
            <summary>
            Returns true when node was released completely and returned to pool.
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroupsBase`1.AddNode(`0)">
            <summary>
            Adds node, asserts when node already exists
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroupsBase`1.RemoveNode(`0)">
            <summary>
            Removes node, asserts when node is not here or node has some existing links
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroupsBase`1.CreateLink(System.Int64,`0,`0)">
            <summary>
            Creates link between parent and child.
            Parent is owner of constraint.
            LinkId must be unique only for parent, for grid it can be packed position of block which created constraint.
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroupsBase`1.BreakLink(System.Int64,`0,`0)">
            <summary>
            Breaks link between parent and child, you can set child to null to find it by linkId.
            Returns true when link was removed, returns false when link was not found.
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroupsBase`1.LinkExists(System.Int64,`0,`0)">
            <summary>
            Returns true if the given link between parent and child exists, you can set child to null to find it by linkId.
            </summary>
        </member>
        <member name="M:VRage.Groups.MyGroupsBase`1.GetGroupNodes(`0)">
            <summary>
            Allocates!!
            Returns list of nodes datas in group
            </summary>
            <param name="nodeInGroup"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Groups.MyGroupsBase`1.HasSameGroup(`0,`0)">
            <summary>
            Returns true if any link between nodes exists.
            </summary>
            <param name="nodeA"></param>
            <param name="nodeB"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.ResetableMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Original C# implementation
            </summary>
        </member>
        <member name="M:VRage.ResetableMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Original C# implementation
            </summary>
        </member>
        <member name="M:VRage.ByteStream.#ctor(System.Int32,System.Boolean)">
            <summary>
            Create non-resetable Stream, optionally expandable
            </summary>
        </member>
        <member name="M:VRage.ByteStream.#ctor">
            <summary>
            Creates resetable Stream
            </summary>
        </member>
        <member name="M:VRage.ByteStream.#ctor(System.Byte[],System.Int32)">
            <summary>
            Creates and initializes resetable Stream
            </summary>
        </member>
        <member name="M:VRage.ByteStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Original C# implementation
            </summary>
        </member>
        <member name="M:VRage.ByteStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Original C# implementation
            </summary>
        </member>
        <member name="T:VRage.MyFixedPoint">
            <summary>
            Fixed point number represented as 64-bit integer with 6 decimal places (one millionts)
            </summary>
        </member>
        <member name="M:VRage.MyFixedPoint.SerializeString">
            <summary>
            For XmlSerialization, format is 123.456789
            </summary>
        </member>
        <member name="M:VRage.MyFixedPoint.DeserializeStringSafe(System.String)">
            <summary>
            For XmlSerialization, format is 123.456789
            Handles double and decimal formats too.
            </summary>
        </member>
        <member name="T:VRage.MyTupleComparer`2">
            <summary>
            Use this as a custom comparer for the dictionaries, where the tuple is a key
            </summary>
        </member>
        <member name="T:VRage.MyTupleComparer`3">
            <summary>
            Use this as a custom comparer for the dictionaries, where the tuple is a key
            </summary>
        </member>
        <member name="T:VRage.Ref`1">
            <summary>
            Good for struct wrapping to store it as ref value in dictionary.
            </summary>
        </member>
        <member name="M:VRage.FastResourceLockExtensions.AcquireSharedUsing(VRage.FastResourceLock)">
            <summary>
            Call dispose or use using block to release lock
            </summary>
        </member>
        <member name="M:VRage.FastResourceLockExtensions.AcquireExclusiveUsing(VRage.FastResourceLock)">
            <summary>
            Call dispose or use using block to release lock
            </summary>
        </member>
        <member name="M:VRage.IResourceLock.AcquireExclusive">
            <summary>
            Acquires the lock in exclusive mode, blocking if necessary.
            </summary>
        </member>
        <member name="M:VRage.IResourceLock.AcquireShared">
            <summary>
            Acquires the lock in shared mode, blocking if necessary.
            </summary>
        </member>
        <member name="M:VRage.IResourceLock.ReleaseExclusive">
            <summary>
            Releases the lock in exclusive mode.
            </summary>
        </member>
        <member name="M:VRage.IResourceLock.ReleaseShared">
            <summary>
            Releases the lock in shared mode.
            </summary>
        </member>
        <member name="M:VRage.IResourceLock.TryAcquireExclusive">
            <summary>
            Attempts to acquire the lock in exclusive mode.
            </summary>
            <returns>Whether the lock was acquired.</returns>
        </member>
        <member name="M:VRage.IResourceLock.TryAcquireShared">
            <summary>
            Attempts to acquire the lock in shared mode.
            </summary>
            <returns>Whether the lock was acquired.</returns>
        </member>
        <member name="T:VRage.Parallelization.MyPausableJob">
            <summary>
            Allows to pause one thread at exact points
            </summary>
        </member>
        <member name="T:VRage.Profiler.MyProfiler">
            <summary>
            Part of MyRenderProfiler, this is per-thread profiler
            </summary>
        </member>
        <member name="F:VRage.Profiler.MyProfiler.AutoCommit">
            <summary>
            Enable for background workers.
            It will automatically commit after top level profiling block is closed
            </summary>
        </member>
        <member name="M:VRage.Profiler.MyProfiler.OnHistorySafe">
            <summary>
            End operation on history data
            </summary>
        </member>
        <member name="M:VRage.Profiler.MyProfiler.CommitFrame">
            <summary>
            Adds current frame to history and clear it
            Returns number of calls this frame
            </summary>
        </member>
        <member name="M:VRage.Profiler.MyProfiler.ClearFrame">
            <summary>
            Clears current frame.
            </summary>
        </member>
        <member name="M:VRage.Profiler.MyProfilerBlock.Clear">
            <summary>
            Clears immediate data
            </summary>
        </member>
        <member name="T:VRage.Security.Md5.Hash">
            <summary>
            Represent digest with ABCD
            </summary>
        </member>
        <member name="M:VRage.Security.Md5.Hash.ReverseByte(System.UInt32)">
            <summary>
            perform a ByteReversal on a number
            </summary>
            <param name="uiNumber">value to be reversed</param>
            <returns>reversed value</returns>
        </member>
        <member name="M:VRage.Security.Md5.RotateLeft(System.UInt32,System.UInt16)">
            <summary>
            Left rotates the input word
            </summary>
            <param name="uiNumber">a value to be rotated</param>
            <param name="shift">no of bits to be rotated</param>
            <returns>the rotated value</returns>
        </member>
        <member name="F:VRage.Security.Md5.T">
            <summary>
            lookup table 4294967296*sin(i)
            </summary>
        </member>
        <member name="M:VRage.Security.Md5.ComputeHash(System.Byte[])">
            <summary>
            calculat md5 signature of the string in Input
            </summary>
            <returns> Digest: the finger print of msg</returns>
        </member>
        <member name="M:VRage.Security.Md5.ComputeHash(System.Byte[],VRage.Security.Md5.Hash)">
            <summary>
            calculat md5 signature of the string in Input
            </summary>
            <returns> Digest: the finger print of msg</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:VRage.Security.Md5.TransF(System.UInt32@,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt16,System.UInt32,System.UInt32*)" -->
        <!-- Badly formed XML comment ignored for member "M:VRage.Security.Md5.TransG(System.UInt32@,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt16,System.UInt32,System.UInt32*)" -->
        <member name="M:VRage.Security.Md5.TransH(System.UInt32@,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt16,System.UInt32,System.UInt32*)">
            <summary>
            perform transformatio using h(b^c^d)
            </summary>
        </member>
        <member name="M:VRage.Security.Md5.TransI(System.UInt32@,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt16,System.UInt32,System.UInt32*)">
            <summary>
            perform transformatio using i (c^(b|~d))
            </summary>
        </member>
        <member name="M:VRage.Security.Md5.PerformTransformation(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32*)">
            <summary>
            Perform All the transformation on the data
            </summary>
            <param name="A">A</param>
            <param name="B">B </param>
            <param name="C">C</param>
            <param name="D">D</param>
        </member>
        <member name="M:VRage.Security.Md5.CopyBlock(System.Byte[],System.UInt32,System.UInt32*)">
            <summary>
            Copies a 512 bit block into X as 16 32 bit words
            </summary>
            <param name="bMsg"> source buffer</param>
            <param name="block">no of block to copy starting from 0</param>
        </member>
        <member name="M:VRage.Stats.MyStats.Clear">
            <summary>
            Clears all stats (doesn't remove them)
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.RemoveAll">
            <summary>
            Removes all stats
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.Remove(System.String)">
            <summary>
            Remove a stat
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.Increment(System.String,System.Int32,System.Int32)">
            <summary>
            Increments an internal counter with given name and sets it to refresh after given time has passed.
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.Write(System.String,System.Single,VRage.Stats.MyStatTypeEnum,System.Int32,System.Int32,System.Int32)">
            <summary>
            Write stat, colon and space is added automatically
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.Write(System.String,System.Int64,VRage.Stats.MyStatTypeEnum,System.Int32,System.Int32,System.Int32)">
            <summary>
            Write stat, colon and space is added automatically
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.WriteFormat(System.String,System.Single,VRage.Stats.MyStatTypeEnum,System.Int32,System.Int32,System.Int32)">
            <summary>
            Write stat using format string
            Number of arguments in format string:
            MinMaxAvg - three
            MinMax - two
            Other - one
            </summary>
        </member>
        <member name="M:VRage.Stats.MyStats.WriteFormat(System.String,System.Int64,VRage.Stats.MyStatTypeEnum,System.Int32,System.Int32,System.Int32)">
            <summary>
            Write stat using format string
            Number of arguments in format string:
            MinMaxAvg - three
            MinMax - two
            Other - one
            </summary>
        </member>
        <member name="M:VRage.Trace.MyWintraceWrapper.Flush">
            <inheritdoc />
        </member>
        <member name="P:VRage.Trace.MyWintraceWrapper.Enabled">
            <inheritdoc />
        </member>
        <member name="T:VRage.Utils.MyStringId">
            <summary>
            Generates unique IDs for strings. When used as key for hash tables (Dictionary or HashSet)
            always pass in MyStringId.Comparer, otherwise lookups will allocate memory! Never serialize to network or disk!
            
            IDs are created sequentially as they get requested so two IDs might be different between sessions or clients and
            server. You can safely use ToString() as it will not allocate.
            </summary>
        </member>
        <member name="M:VRage.Utils.MyStringUtils.UpdateControlsToNotificationFriendly(System.String)">
            <summary>
            Converts '[' and ']' into their UTF form to avoid being removed by notification processing system.
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyStringUtils.UpdateControlsFromNotificationFriendly(System.String)">
            <summary>
            Converts '[' and ']' UTF form to the regular characters.
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyStringUtils.UpdateControlsFromNotificationFriendly(System.Text.StringBuilder)">
            <summary>
            Converts '[' and ']' UTF form to the regular characters.
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:VRage.Utils.MyStringUtils.GetUniversalHashCode(System.String)">
            <summary>
            Platform agnostic hash code (same as x64 .NET Framework)
            </summary>
        </member>
        <member name="M:System.Reflection.FieldAccess.FieldHelper`2.#ctor(System.Reflection.FieldInfo)">
            <inheritdoc />
        </member>
        <member name="M:System.ArrayExtensions.BinaryIntervalSearch``1(``0[],``0)">
            <summary>
            Do a binary search in an array of interval limits, each member is the interval threshold.
            
            The result is the index of the interval that contains the value searched for.
            
            If the interval array is empty 0 is returned (as we assume we have only the (-,+) interval).
            </summary>
            <returns>[0, Length]</returns>
        </member>
        <member name="M:System.ArrayExtensions.BinaryIntervalSearch``1(``0[],System.Func{``0,System.Int32})">
            <summary>
            Do a binary search in an array of interval limits, each member is the interval threshold.
            
            The result is the index of the interval that contains the value searched for.
            
            If the interval array is empty 0 is returned (as we assume we have only the (-,+) interval).
            
            The search is done using the specified search method. The method must return an integer
            representing whether the argument is greater (1), smaller (-1) or equal(0) to the search condition.
            </summary>
            <param name="self">The array to search into.</param>
            
            <returns>[0, Length]</returns>
        </member>
        <member name="M:System.ArrayExtensions.OfTypeFast``2(``0[])">
            <summary>
            OfType on array implemented without allocations
            </summary>
        </member>
        <member name="M:System.ArrayExtensions.Contains``1(``0[],``0)">
            <summary>
            Allocates for struct elements!
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.RemoveAtFast``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Remove element at index by replacing it with last element in list.
            Removing is very fast but it breaks order of items in list!
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">The list.</param>
            <param name="index">The index.</param>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.Move``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
            <summary>
            Moves item in the list from original index to target index, reordering elements as if Remove and Insert was called.
            However, only elements in the range between the two indices are affected.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.RemoveIndices``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{System.Int32})">
            Remove each element in indices from the list.
            
            The list of indices must be sorted.
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.BinaryIntervalSearch``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IComparer{``0})">
            Do a binary search in an array of interval limits, each member is the interval threshold.
            
            The result is the index of the interval that contains the value searched for.
            
            If the interval array is empty 0 is returned (as we assume we have only the (-,+) interval).
            
            Return range: [0, Length]
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.BinaryIntervalSearch``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean})">
            <summary>
            Do a binary search in an array of interval limits, each member is the interval threshold.
            
            The result is the index of the interval that contains the value searched for.
            
            If the interval array is empty 0 is returned (as we assume we have only the (-,+) interval).
            
            Return range: [0, Length]
            </summary>
        </member>
        <member name="M:System.DoubleExtensions.IsValid(System.Double)">
            <summary>
            Returns true if double is valid
            </summary>
        </member>
        <member name="F:System.Linq.Expressions.ExpressionExtension.Factory">
            <summary>
            The factory used by this class.
            </summary>
        </member>
        <member name="M:System.FloatExtensions.IsValid(System.Single)">
            <summary>
            Returns true if float is not NaN or infinity.
            </summary>
        </member>
        <member name="M:System.Net.IPAddressExtensions.TryParseEndpoint(System.String,System.Net.IPEndPoint@,System.UInt32)">
            <summary>
            Parses IP Endpoint from string. Expected format is the same as output by <see cref="M:System.Net.IPEndPoint.ToString"/>.
            </summary>
        </member>
        <member name="M:System.StreamExtensions.UnwrapGZip(System.IO.Stream)">
            <summary>
            Checks for GZip header and if found, returns decompressed Stream, otherwise original Stream
            </summary>
        </member>
        <member name="M:System.StreamExtensions.WrapGZip(System.IO.Stream,System.Boolean,System.Boolean)">
            <summary>
            Wraps stream into GZip compression stream resulting in writing compressed stream
            </summary>
        </member>
        <member name="M:System.StreamExtensions.WriteNoAlloc(System.IO.Stream,System.String,System.Text.Encoding)">
            <summary>
            Writes byte count prefixed encoded text into the file. Byte count is written as 7-bit encoded 32-bit int.
            If no encoding is specified, UTF-8 will be used. Byte count prefix specifies number of bytes taken up by
            the string, not length of the string itself.
            Note that this method may allocate if the size of encoded string exceeds size of prepared buffer.
            </summary>
        </member>
        <member name="M:System.Text.StringBuilderExtensions_2.CompareUpdate(System.Text.StringBuilder,System.String)">
            <summary>
            Compares string builder with text,
            when it's different, Clears string builder and Appends text.
            Returns true when original string builder was modified.
            </summary>
        </member>
        <member name="M:System.Text.StringBuilderExtensions_2.CompareUpdate(System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>
            Compares string builder with text,
            when it's different, Clears string builder and Appends text.
            Returns true when original string builder was modified.
            </summary>
        </member>
        <member name="M:System.Text.StringBuilderExtensions_2.TrimEnd(System.Text.StringBuilder,System.Int32)">
            <summary>
            Removes the specified number of characters from the end.
            </summary>
            <param name="sb">The sb.</param>
            <param name="length">The length.</param>
        </member>
        <member name="M:System.Text.StringBuilderExtensions_2.TrimTrailingWhitespace(System.Text.StringBuilder)">
            <summary>
            Removes whitespace from the end.
            </summary>
        </member>
        <member name="M:System.Text.StringBuilderExtensions_2.CompareTo(System.Text.StringBuilder,System.String)">
            <summary>
            returns 0 if its the same
            </summary>
            <param name="self"></param>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:System.PreloadRequiredAttribute">
            <summary>
            Specifies that this class requires preload before running the game
            Preload is be done when starting the app
            </summary>
        </member>
        <member name="M:LitJson.JsonData.ContainsKey(System.String)">
            <summary>
            Determines whether the json contains an element that has the specified key.
            </summary>
            <param name="key">The key to locate in the json.</param>
            <returns>true if the json contains an element that has the specified key; otherwise, false.</returns>
        </member>
        <member name="T:ParallelTasks.MySpinWait">
            <summary>
            Provides support for spin-based waiting.
            </summary>
            <remarks>
            <para>
            <see cref="T:ParallelTasks.MySpinWait"/> encapsulates common spinning logic. On single-processor machines, yields are
            always used instead of busy waits, and on computers with Intel processors employing Hyper-Threading
            technology, it helps to prevent hardware thread starvation. MySpinWait encapsulates a good mixture of
            spinning and true yielding.
            </para>
            <para>
            <see cref="T:ParallelTasks.MySpinWait"/> is a value type, which means that low-level code can utilize MySpinWait without
            fear of unnecessary allocation overheads. MySpinWait is not generally useful for ordinary applications.
            In most cases, you should use the synchronization classes provided by the .NET Framework, such as
            <see cref="T:System.Threading.Monitor"/>. For most purposes where spin waiting is required, however,
            the <see cref="T:ParallelTasks.MySpinWait"/> type should be preferred over the <see
            cref="M:System.Threading.Thread.SpinWait(System.Int32)"/> method.
            </para>
            <para>
            While MySpinWait is designed to be used in concurrent applications, it is not designed to be
            used from multiple threads concurrently.  MySpinWait's members are not thread-safe.  If multiple
            threads must spin, each should use its own instance of MySpinWait.
            </para>
            </remarks>
        </member>
        <member name="P:ParallelTasks.MySpinWait.Count">
            <summary>
            Gets the number of times <see cref="M:ParallelTasks.MySpinWait.SpinOnce"/> has been called on this instance.
            </summary>
        </member>
        <member name="P:ParallelTasks.MySpinWait.NextSpinWillYield">
            <summary>
            Gets whether the next call to <see cref="M:ParallelTasks.MySpinWait.SpinOnce"/> will yield the processor, triggering a
            forced context switch.
            </summary>
            <value>Whether the next call to <see cref="M:ParallelTasks.MySpinWait.SpinOnce"/> will yield the processor, triggering a
            forced context switch.</value>
            <remarks>
            On a single-CPU machine, <see cref="M:ParallelTasks.MySpinWait.SpinOnce"/> always yields the processor. On machines with
            multiple CPUs, <see cref="M:ParallelTasks.MySpinWait.SpinOnce"/> may yield after an unspecified number of calls.
            </remarks>
        </member>
        <member name="M:ParallelTasks.MySpinWait.SpinOnce">
            <summary>
            Performs a single spin.
            </summary>
            <remarks>
            This is typically called in a loop, and may change in behavior based on the number of times a
            <see cref="M:ParallelTasks.MySpinWait.SpinOnce"/> has been called thus far on this instance.
            </remarks>
        </member>
        <member name="M:ParallelTasks.MySpinWait.Reset">
            <summary>
            Resets the spin counter.
            </summary>
            <remarks>
            This makes <see cref="M:ParallelTasks.MySpinWait.SpinOnce"/> and <see cref="P:ParallelTasks.MySpinWait.NextSpinWillYield"/> behave as though no calls
            to <see cref="M:ParallelTasks.MySpinWait.SpinOnce"/> had been issued on this instance. If a <see cref="T:ParallelTasks.MySpinWait"/> instance
            is reused many times, it may be useful to reset it to avoid yielding too soon.
            </remarks>
        </member>
        <member name="M:ParallelTasks.MySpinWait.SpinUntil(System.Func{System.Boolean})">
            <summary>
            Spins until the specified condition is satisfied.
            </summary>
            <param name="condition">A delegate to be executed over and over until it returns true.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="condition"/> argument is null.</exception>
        </member>
        <member name="M:ParallelTasks.MySpinWait.SpinUntil(System.Func{System.Boolean},System.TimeSpan)">
            <summary>
            Spins until the specified condition is satisfied or until the specified timeout is expired.
            </summary>
            <param name="condition">A delegate to be executed over and over until it returns true.</param>
            <param name="timeout">
            A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, 
            or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <returns>True if the condition is satisfied within the timeout; otherwise, false</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="condition"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative number
            other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue"/>.</exception>
        </member>
        <member name="M:ParallelTasks.MySpinWait.SpinUntil(System.Func{System.Boolean},System.Int32)">
            <summary>
            Spins until the specified condition is satisfied or until the specified timeout is expired.
            </summary>
            <param name="condition">A delegate to be executed over and over until it returns true.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see
            cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <returns>True if the condition is satisfied within the timeout; otherwise, false</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="condition"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
        </member>
        <member name="T:ParallelTasks.PlatformHelper">
            <summary>
            A helper class to get the number of processors, it updates the numbers of processors every sampling interval.
            </summary>
        </member>
        <member name="P:ParallelTasks.PlatformHelper.ProcessorCount">
            <summary>
            Gets the number of available processors
            </summary>
        </member>
        <member name="P:ParallelTasks.PlatformHelper.IsSingleProcessor">
            <summary>
            Gets whether the current machine has only a single processor.
            </summary>
        </member>
        <member name="T:ParallelTasks.TimeoutHelper">
            <summary>
            A helper class to capture a start time using Environment.TickCout as a time in milliseconds, also updates a given timeout bu subtracting the current time from
            the start time
            </summary>
        </member>
        <member name="M:ParallelTasks.TimeoutHelper.GetTime">
            <summary>
            Returns start time
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParallelTasks.TimeoutHelper.UpdateTimeOut(System.Int64,System.Int32)">
            <summary>
            Helper function to measure and update the elapsed time
            </summary>
            <param name="startTime"> The first time (in milliseconds) observed when the wait started</param>
            <param name="originalWaitMillisecondsTimeout">The orginal wait timeoutout in milliseconds</param>
            <returns>The new wait time in milliseconds, -1 if the time expired</returns>
        </member>
        <member name="M:ParallelTasks.DependencyBatch.Add(System.Action)">
             <summary>
             <para>
             Adds new job for execution.
             </para>
             
             <para>
             !!! All jobs need to be scheduled before the batch is started !!!
             </para>
            
             <para>
             Note: In case there is multiple dependency-free jobs ready to be executed scheduler prefers jobs in order in which they were added to batch.
                   Use that to you advantage when optimizing for cache coherency for example.
             </para>
             </summary>
             <returns>Job id. See <see cref="M:ParallelTasks.DependencyBatch.Job(System.Int32)"/>.<see cref="M:ParallelTasks.DependencyBatch.StartToken.Starts(System.Int32)"/></returns>
        </member>
        <member name="M:ParallelTasks.DependencyBatch.StartToken.Starts(System.Int32)">
            <summary>
            Marks task to be executed only after `this` task is done
            </summary>
        </member>
        <member name="M:ParallelTasks.DependencyBatch.Job(System.Int32)">
            <summary>
            Entry point of dependency fluent API.
            !!! Jobs needs to be queried in ascending order !!!
            </summary>
            <returns>Dependency fluent API</returns>
        </member>
        <member name="T:ParallelTasks.Future`1">
            <summary>
            A task struct which can return a result.
            </summary>
            <typeparam name="T">The type of result this future calculates.</typeparam>
        </member>
        <member name="P:ParallelTasks.Future`1.IsComplete">
            <summary>
            Gets a value which indicates if this future has completed.
            </summary>
        </member>
        <member name="P:ParallelTasks.Future`1.Exceptions">
            <summary>
            Gets an array containing any exceptions thrown by this future.
            </summary>
        </member>
        <member name="M:ParallelTasks.Future`1.GetResult">
            <summary>
            Gets the result. Blocks the calling thread until the future has completed execution.
            This can only be called once!
            </summary>
            <returns></returns>
        </member>
        <member name="M:ParallelTasks.Hashtable`2.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:ParallelTasks.Hashtable`2"/> class.
            </summary>
            <param name="initialCapacity">The initial capacity of the table.</param>
        </member>
        <member name="M:ParallelTasks.Hashtable`2.Add(`0,`1)">
            <summary>
            Adds an item to this hashtable.
            </summary>
            <param name="key">The key at which to add the item.</param>
            <param name="data">The data to add.</param>
        </member>
        <member name="M:ParallelTasks.Hashtable`2.UnsafeSet(`0,`1)">
            <summary>
            Sets the value of the item at the specified key location.
            This is only guaranteed to work correctly if no other thread is modifying the same key.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The new value.</param>
        </member>
        <member name="M:ParallelTasks.Hashtable`2.TryGet(`0,`1@)">
            <summary>
            Tries to get the data at the specified key location.
            </summary>
            <param name="key">The key to search for.</param>
            <param name="data">The data at the key location.</param>
            <returns><c>true</c> if the data was found; else <c>false</c>.</returns>
        </member>
        <member name="M:ParallelTasks.Hashtable`2.Remove(`0)">
            <summary>
            Removes the data at the specified key location.
            </summary>
            <param name="key">The key.</param>
        </member>
        <member name="M:ParallelTasks.Hashtable`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:ParallelTasks.Hashtable`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="T:ParallelTasks.WorkPriority">
            <summary>
            These values are indices into array of queues which is searched starting at 0.
            </summary>
        </member>
        <member name="T:ParallelTasks.IWork">
            <summary>
            An interface for a piece of work which can be executed by ParallelTasks.
            </summary>
        </member>
        <member name="M:ParallelTasks.IWork.DoWork(ParallelTasks.WorkData)">
            <summary>
            Executes the work.
            </summary>
        </member>
        <member name="P:ParallelTasks.IWork.Options">
            <summary>
            Gets options specifying how this work may be executed.
            </summary>
        </member>
        <member name="T:ParallelTasks.IWorkScheduler">
            <summary>
            An interface defining a task scheduler.
            </summary>
        </member>
        <member name="P:ParallelTasks.IWorkScheduler.ThreadCount">
            <summary>
            Gets a number of threads.
            This number must be correct, because it's used to run per-thread initialization task on all threads (by using barrier)
            </summary>
        </member>
        <member name="M:ParallelTasks.IWorkScheduler.Schedule(ParallelTasks.Task)">
            <summary>
            Schedules a task for execution.
            </summary>
            <param name="item">The task to schedule.</param>
        </member>
        <member name="M:ParallelTasks.IWorkScheduler.WaitForTasksToFinish(System.TimeSpan)">
            <summary>
            Wait for all tasks to finish the work.
            </summary>
        </member>
        <member name="M:ParallelTasks.IWorkScheduler.ReadAndClearExecutionTime">
            <summary>
            Returns number of ticks the parallel threads spent working on scheduled tasks since last request or since the threadpool was created if no query was executed yet.
            Result includes time spent working on tasks that are not finished fully (e.g. running) at the moment of request.
            Does not represent actual time spent on CPU, only time spent by "not waiting for a task"!
            </summary>
        </member>
        <member name="T:ParallelTasks.Parallel">
            <summary>
            A static class containing factory methods for creating tasks.
            </summary>
        </member>
        <member name="M:ParallelTasks.Parallel.RunCallbacks">
            <summary>
            Executes all task callbacks for the thread calling this function.
            It is thread safe.
            </summary>
        </member>
        <member name="P:ParallelTasks.Parallel.ProcessorAffinity">
            <summary>
            Gets or sets the processor affinity of the worker threads.
            </summary>
            <value>
            The processor affinity of the worker threads. The default value is <c>{ 3, 4, 5, 1 }</c>.
            </value>
            <remarks>
            <para>
            In the .NET Compact Framework for Xbox 360 the processor affinity determines the processors 
            on which a thread runs. 
            </para>
            <para>
            <strong>Note:</strong> The processor affinity is only relevant in the .NET Compact Framework 
            for Xbox 360. Setting the processor affinity has no effect in Windows!
            </para>
            <para>
            <strong>Important:</strong> The processor affinity needs to be set before any parallel tasks
            are created. Changing the processor affinity afterwards has no effect.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="value" /> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            The specified array is empty or contains invalid values.
            </exception>
        </member>
        <member name="P:ParallelTasks.Parallel.Scheduler">
            <summary>
            Gets or sets the work scheduler.
            </summary>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="value"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:ParallelTasks.Parallel.StartBackground(ParallelTasks.IWork)">
            <summary>
            Starts a task in a secondary worker thread. Intended for long running, blocking, work
            such as I/O.
            </summary>
            <param name="work">The work to execute.</param>
            <returns>A task which represents one execution of the work.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.StartBackground(ParallelTasks.IWork,System.Action)">
            <summary>
            Starts a task in a secondary worker thread. Intended for long running, blocking, work
            such as I/O.
            </summary>
            <param name="work">The work to execute.</param>
            <param name="completionCallback">A method which will be called in Parallel.RunCallbacks() once this task has completed.</param>
            <returns>A task which represents one execution of the work.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="work"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Invalid number of maximum threads set in <see cref="P:ParallelTasks.IWork.Options"/>.
            </exception>
        </member>
        <member name="M:ParallelTasks.Parallel.StartBackground(System.Action)">
            <summary>
            Starts a task in a secondary worker thread. Intended for long running, blocking, work
            such as I/O.
            </summary>
            <param name="action">The work to execute.</param>
            <returns>A task which represents one execution of the action.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.StartBackground(System.Action,System.Action)">
            <summary>
            Starts a task in a secondary worker thread. Intended for long running, blocking, work
            such as I/O.
            </summary>
            <param name="action">The work to execute.</param>
            <param name="completionCallback">A method which will be called in Parallel.RunCallbacks() once this task has completed.</param>
            <returns>A task which represents one execution of the action.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="action"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:ParallelTasks.Parallel.StartBackground(System.Action{ParallelTasks.WorkData},System.Action{ParallelTasks.WorkData},ParallelTasks.WorkData)">
            <summary>
            Starts a task in a secondary worker thread. Intended for long running, blocking work such as I/O.
            </summary>
            <param name="action">The work to execute.</param>
            <param name="completionCallback">A method which will be called in Parallel.RunCallbacks() once this task has completed.</param>
            <param name="workData">Data to be passed along both the work and the completion callback.</param>
            <returns>A task which represents one execution of the action.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="action"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:ParallelTasks.Parallel.Start(ParallelTasks.IWork)">
            <summary>
            Creates and starts a task to execute the given work.
            </summary>
            <param name="work">The work to execute in parallel.</param>
            <returns>A task which represents one execution of the work.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.Start(ParallelTasks.IWork,System.Action)">
            <summary>
            Creates and starts a task to execute the given work.
            </summary>
            <param name="work">The work to execute in parallel.</param>
            <param name="completionCallback">A method which will be called in Parallel.RunCallbacks() once this task has completed.</param>
            <returns>A task which represents one execution of the work.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="work"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            Invalid number of maximum threads set in <see cref="P:ParallelTasks.IWork.Options"/>.
            </exception>
        </member>
        <member name="M:ParallelTasks.Parallel.Start(System.Action,ParallelTasks.WorkPriority)">
            <summary>
            Creates and starts a task to execute the given work.
            </summary>
            <param name="action">The work to execute in parallel.</param>
            <returns>A task which represents one execution of the work.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.Start(System.Action,System.Action,ParallelTasks.WorkPriority)">
            <summary>
            Creates and starts a task to execute the given work.
            </summary>
            <param name="action">The work to execute in parallel.</param>
            <param name="completionCallback">A method which will be called in Parallel.RunCallbacks() once this task has completed.</param>
            <returns>A task which represents one execution of the work.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.Start(System.Action,ParallelTasks.WorkOptions,ParallelTasks.WorkPriority)">
            <summary>
            Creates and starts a task to execute the given work.
            </summary>
            <param name="action">The work to execute in parallel.</param>
            <param name="options">The work options to use with this action.</param>
            <returns>A task which represents one execution of the work.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.Start(System.Action,ParallelTasks.WorkOptions,System.Action,ParallelTasks.WorkPriority)">
            <summary>
            Creates and starts a task to execute the given work.
            </summary>
            <param name="action">The work to execute in parallel.</param>
            <param name="options">The work options to use with this action.</param>
            <param name="completionCallback">A method which will be called in Parallel.RunCallbacks() once this task has completed.</param>
            <returns>A task which represents one execution of the work.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.Start(System.Action{ParallelTasks.WorkData},System.Action{ParallelTasks.WorkData},ParallelTasks.WorkData,ParallelTasks.WorkOptions,ParallelTasks.WorkPriority)">
            <summary>
            Creates and schedules a task to execute the given work with the given work data.
            </summary>
            <param name="action">The work to execute in parallel.</param>
            <param name="completionCallback">A method which will be called in Parallel.RunCallbacks() once this task has completed.</param>
            <param name="workData">Data to be passed along both the work and the completion callback.</param>
            <returns>A task which represents one execution of the action.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.ScheduleForThread(System.Action{ParallelTasks.WorkData},ParallelTasks.WorkData,System.Threading.Thread)">
            <summary>
            Creates and schedules a task to execute on the given work-tracking thread.
            If the requested thread that does not execute completion callbacks the callback will never be called.
            </summary>
            <param name="action">The work to execute in parallel.</param>
            <param name="workData">Data to be passed along both the work and the completion callback.</param>
            <param name="thread">Thread to execute the callback on. If not provided this is the calling thread.</param>
            <returns>A task which represents one execution of the action.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.StartOnEachWorker(System.Action)">
            <summary>
            Starts same task on each worker, each worker executes this task exactly once.
            Good for initialization and release of per-thread resources.
            THIS CANNOT BE RUN FROM ANY WORKER!
            </summary>
        </member>
        <member name="M:ParallelTasks.Parallel.Start``1(System.Func{``0},ParallelTasks.WorkPriority)">
            <summary>
            Creates and starts a task which executes the given function and stores the result for later retrieval.
            </summary>
            <typeparam name="T">The type of result the function returns.</typeparam>
            <param name="function">The function to execute in parallel.</param>
            <returns>A future which represults one execution of the function.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.Start``1(System.Func{``0},System.Action,ParallelTasks.WorkPriority)">
            <summary>
            Creates and starts a task which executes the given function and stores the result for later retrieval.
            </summary>
            <typeparam name="T">The type of result the function returns.</typeparam>
            <param name="function">The function to execute in parallel.</param>
            <param name="completionCallback">A method which will be called in Parallel.RunCallbacks() once this task has completed.</param>
            <returns>A future which represults one execution of the function.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.Start``1(System.Func{``0},ParallelTasks.WorkOptions,ParallelTasks.WorkPriority)">
            <summary>
            Creates and starts a task which executes the given function and stores the result for later retrieval.
            </summary>
            <typeparam name="T">The type of result the function returns.</typeparam>
            <param name="function">The function to execute in parallel.</param>
            <param name="options">The work options to use with this action.</param>
            <returns>A future which represents one execution of the function.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.Start``1(System.Func{``0},ParallelTasks.WorkOptions,System.Action,ParallelTasks.WorkPriority)">
            <summary>
            Creates and starts a task which executes the given function and stores the result for later retrieval.
            </summary>
            <typeparam name="T">The type of result the function returns.</typeparam>
            <param name="function">The function to execute in parallel.</param>
            <param name="options">The work options to use with this action.</param>
            <param name="completionCallback">A method which will be called in Parallel.RunCallbacks() once this task has completed.</param>
            <returns>A future which represents one execution of the function.</returns>
        </member>
        <member name="M:ParallelTasks.Parallel.Do(ParallelTasks.IWork,ParallelTasks.IWork)">
            <summary>
            Executes the given work items potentially in parallel with each other.
            This method will block until all work is completed.
            </summary>
            <param name="a">Work to execute.</param>
            <param name="b">Work to execute.</param>
        </member>
        <member name="M:ParallelTasks.Parallel.Do(ParallelTasks.IWork[])">
            <summary>
            Executes the given work items potentially in parallel with each other.
            This method will block until all work is completed.
            </summary>
            <param name="work">The work to execute.</param>
        </member>
        <member name="M:ParallelTasks.Parallel.Do(System.Action,System.Action)">
            <summary>
            Executes the given work items potentially in parallel with each other.
            This method will block until all work is completed.
            </summary>
            <param name="action1">The work to execute.</param>
            <param name="action2">The work to execute.</param>
        </member>
        <member name="M:ParallelTasks.Parallel.Do(System.Action[])">
            <summary>
            Executes the given work items potentially in parallel with each other.
            This method will block until all work is completed.
            </summary>
            <param name="actions">The work to execute.</param>
        </member>
        <member name="M:ParallelTasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32},ParallelTasks.WorkPriority,System.Nullable{ParallelTasks.WorkOptions})">
            <summary>
            Executes a for loop, where each iteration can potentially occur in parallel with others.
            </summary>
            <param name="startInclusive">The index (inclusive) at which to start iterating.</param>
            <param name="endExclusive">The index (exclusive) at which to end iterating.</param>
            <param name="body">The method to execute at each iteration. The current index is supplied as the parameter.</param>
        </member>
        <member name="M:ParallelTasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32},System.Int32,ParallelTasks.WorkPriority,System.Nullable{ParallelTasks.WorkOptions},System.Boolean)">
            <summary>
            Executes a for loop, where each iteration can potentially occur in parallel with others.
            </summary>
            <param name="startInclusive">The index (inclusive) at which to start iterating.</param>
            <param name="endExclusive">The index (exclusive) at which to end iterating.</param>
            <param name="body">The method to execute at each iteration. The current index is supplied as the parameter.</param>
            <param name="stride">The number of iterations that each processor takes at a time.</param>
        </member>
        <member name="M:ParallelTasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0},ParallelTasks.WorkPriority,System.Nullable{ParallelTasks.WorkOptions},System.Boolean)">
            <summary>
            Executes a foreach loop, where each iteration can potentially occur in parallel with others.
            </summary>
            <typeparam name="T">The type of item to iterate over.</typeparam>
            <param name="collection">The enumerable data source.</param>
            <param name="action">The method to execute at each iteration. The item to process is supplied as the parameter.</param>
        </member>
        <member name="M:ParallelTasks.Parallel.WaitForAll(System.Threading.WaitHandle[],System.TimeSpan)">
            <summary>
            Safe version of WaitHandle.WaitForMultiple, but create new MTA thread when called from STA thread
            </summary>
            <param name="waitHandles"></param>
        </member>
        <member name="T:ParallelTasks.Pool`1">
            <summary>
            A thread safe, non-blocking, object pool.
            </summary>
            <typeparam name="T">The type of item to store. Must be a class with a parameterless constructor.</typeparam>
        </member>
        <member name="M:ParallelTasks.Pool`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ParallelTasks.Pool`1"/> class.
            </summary>
        </member>
        <member name="M:ParallelTasks.Pool`1.Get(System.Threading.Thread)">
            <summary>
            Gets an instance from the pool.
            </summary>
            <returns>An instance of <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:ParallelTasks.Pool`1.Return(System.Threading.Thread,`0)">
            <summary>
            Returns an instance to the pool, so it is available for re-use.
            It is advised that the item is reset to a default state before being returned.
            </summary>
            <param name="instance">The instance to return to the pool.</param>
        </member>
        <member name="T:ParallelTasks.PrioritizedScheduler">
            <summary>
            Sheduler that supports interruption of normal 
            </summary>
        </member>
        <member name="P:ParallelTasks.PrioritizedScheduler.ThreadCount">
            <summary>
            Reveals only the count of one thread array. This value is intended to be used as a "number of threads that can run in parallel."
            </summary>
        </member>
        <member name="M:ParallelTasks.PrioritizedScheduler.#ctor(System.Int32,System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="threadCount">Number of threads in each worker group.</param>
        </member>
        <member name="M:ParallelTasks.PrioritizedScheduler.InitializeWorkerArrays(System.Int32,System.Boolean)">
            <summary>
            Initialize all worker arrays.
            </summary>
            <param name="threadCount">Each array of workers will contain number of threads = threadCount.</param>
        </member>
        <member name="T:ParallelTasks.PrioritizedScheduler.WorkerArray">
            <summary>
            Worker array groups workers of the same thread priority.
            It also contains the queues of tasks belonging to this thread priority.
            </summary>
        </member>
        <member name="F:ParallelTasks.PrioritizedScheduler.WorkerArray.m_prioritizedScheduler">
            <summary>
            Reference to the scheduler.
            </summary>
        </member>
        <member name="F:ParallelTasks.PrioritizedScheduler.WorkerArray.m_workerArrayIndex">
            <summary>
            Index of this worker array.
            </summary>
        </member>
        <member name="F:ParallelTasks.PrioritizedScheduler.WorkerArray.m_taskQueue">
            <summary>
            Task queues. Even in one worker group, tasks will be sorted according to their priority.
            </summary>
        </member>
        <member name="F:ParallelTasks.PrioritizedScheduler.WorkerArray.m_workers">
            <summary>
            Array of worker threads.
            </summary>
        </member>
        <member name="P:ParallelTasks.PrioritizedScheduler.WorkerArray.Workers">
            <summary>
            Array of worker threads.
            </summary>
        </member>
        <member name="M:ParallelTasks.PrioritizedScheduler.WorkerArray.#ctor(ParallelTasks.PrioritizedScheduler,System.Int32,System.Int32,System.Threading.ThreadPriority)">
            <summary>
            Constructor of the worker array.
            </summary>
            <param name="prioritizedScheduler">Scheduler, owner of this group.</param>
        </member>
        <member name="M:ParallelTasks.PrioritizedScheduler.WorkerArray.TryGetTask(ParallelTasks.Task@)">
            <summary>
            Try getting the task from the internal queue.
            </summary>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="M:ParallelTasks.PrioritizedScheduler.WorkerArray.Schedule(ParallelTasks.Task)">
            <summary>
            Schedule the task in this worker array.
            </summary>
            <param name="task"></param>
            <param name="priority"></param>
        </member>
        <member name="T:ParallelTasks.PrioritizedScheduler.Worker">
            <summary>
            One worker thread of the prioritized scheduler.
            </summary>
        </member>
        <member name="P:ParallelTasks.PrioritizedScheduler.Worker.Thread">
            <summary>
            Get the underlying system thread.
            </summary>
        </member>
        <member name="T:ParallelTasks.Semaphore">
            <summary>
            A semaphore class.
            </summary>
        </member>
        <member name="M:ParallelTasks.Semaphore.#ctor(System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:ParallelTasks.Semaphore"/> class.
            </summary>
            <param name="maximumCount"></param>
        </member>
        <member name="M:ParallelTasks.Semaphore.WaitOne">
            <summary>
            Blocks the calling thread until resources are made available, then consumes one resource.
            </summary>
        </member>
        <member name="M:ParallelTasks.Semaphore.Release">
            <summary>
            Adds one resource.
            </summary>
        </member>
        <member name="T:ParallelTasks.Singleton`1">
            <summary>
            Implements a singleton instance of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of object to create a singleton instance of.</typeparam>
        </member>
        <member name="P:ParallelTasks.Singleton`1.Instance">
            <summary>
            Gets a singleton instance.
            </summary>
            <value>The instance.</value>
        </member>
        <member name="T:ParallelTasks.Task">
            <summary>
            A struct which represents a single execution of an IWork instance.
            </summary>
        </member>
        <member name="P:ParallelTasks.Task.IsComplete">
            <summary>
            Gets a value which indicates if this task has completed.
            </summary>
        </member>
        <member name="P:ParallelTasks.Task.Exceptions">
            <summary>
            Gets an array containing any exceptions thrown by this task.
            </summary>
        </member>
        <member name="M:ParallelTasks.Task.WaitOrExecute(System.Boolean)">
            <summary>
            Waits for the task to complete.
            </summary>
        </member>
        <member name="T:ParallelTasks.TaskException">
            <summary>
            An exception thrown when an unhandled exception is thrown within a task.
            </summary>
        </member>
        <member name="P:ParallelTasks.TaskException.InnerExceptions">
            <summary>
            Gets an array containing any unhandled exceptions that were thrown by the task.
            </summary>
        </member>
        <member name="M:ParallelTasks.TaskException.#ctor(System.Exception[])">
            <summary>
            Creates a new instance of the <see cref="T:ParallelTasks.TaskException"/> class.
            </summary>
            <param name="inner">The unhandled exceptions thrown by the task.</param>
        </member>
        <member name="T:ParallelTasks.WorkOptions">
            <summary>
            A struct containing options about how an IWork instance can be executed.
            </summary>
        </member>
        <member name="P:ParallelTasks.WorkOptions.MaximumThreads">
            <summary>
            Gets or sets the maximum number of threads which can concurrently execute this work.
            </summary>
        </member>
        <member name="P:ParallelTasks.WorkOptions.QueueFIFO">
            <summary>
            Gets or sets a value indicating that this work should be queued in a first in first out fashion.
            </summary>
        </member>
        <member name="M:ParallelTasks.WorkOptions.ToString">
            <inheritdoc />
        </member>
        <member name="T:ParallelTasks.WorkStealingScheduler">
            <summary>
            A "work stealing" work scheduler class.
            </summary>
        </member>
        <member name="M:ParallelTasks.WorkStealingScheduler.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:ParallelTasks.WorkStealingScheduler"/> class.
            </summary>
        </member>
        <member name="M:ParallelTasks.WorkStealingScheduler.#ctor(System.Int32,System.Threading.ThreadPriority)">
            <summary>
            Creates a new instance of the <see cref="T:ParallelTasks.WorkStealingScheduler"/> class.
            </summary>
            <param name="numThreads">The number of threads to create.</param>
        </member>
        <member name="M:ParallelTasks.WorkStealingScheduler.Schedule(ParallelTasks.Task)">
            <summary>
            Schedules a task for execution.
            </summary>
            <param name="task">The task to schedule.</param>
        </member>
    </members>
</doc>
